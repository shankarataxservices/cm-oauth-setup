--- Contents of: /home/ubuntu/cm-oauth-setup/compliance-backend/netlify/functions ---

    =� _auth.js

       --- File Content Start ---

// netlify/functions/_auth.js
const { auth, db, json } = require('./_common');

function normalizeRole(role) {
  const r = String(role || '').toUpperCase().trim();
  // Backward compatibility: treat WORKER as ASSOCIATE
  if (r === 'WORKER') return 'ASSOCIATE';
  if (!r) return 'ASSOCIATE';
  return r;
}

async function requireUser(event) {
  const h = event.headers.authorization || event.headers.Authorization || '';
  const token = h.startsWith('Bearer ') ? h.slice(7) : null;
  if (!token) {
    return { error: json(event, 401, { ok: false, error: 'Missing Bearer token' }) };
  }

  const decoded = await auth().verifyIdToken(token);
  const uSnap = await db().collection('users').doc(decoded.uid).get();
  const u = uSnap.exists ? uSnap.data() : null;

  return {
    user: {
      uid: decoded.uid,
      email: decoded.email,
      role: normalizeRole(u?.role || 'ASSOCIATE'),
      active: (u?.active !== false)
    }
  };
}

function requirePartner(event, user) {
  if (String(user.role || '').toUpperCase().trim() !== 'PARTNER') {
    return { error: json(event, 403, { ok: false, error: 'Partner only' }) };
  }
  return { ok: true };
}

function requireCron(event) {
  const s = event.headers['x-cron-secret'] || event.headers['X-Cron-Secret'];
  if (!s || s !== process.env.CRON_SECRET) {
    return { error: json(event, 401, { ok: false, error: 'Bad cron secret' }) };
  }
  return { ok: true };
}

module.exports = { requireUser, requirePartner, requireCron };

       --- File Content End ---


    =� _common.js

       --- File Content Start ---

// netlify/functions/_common.js
const admin = require('firebase-admin');
const { google } = require('googleapis');
const { Readable } = require('stream');

let inited = false;
function init() {
  if (inited) return;
  const sa = JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT);
  admin.initializeApp({ credential: admin.credential.cert(sa) });
  inited = true;
}
function db() { init(); return admin.firestore(); }
function auth() { init(); return admin.auth(); }

// ===== Google OAuth =====
function oauthClient() {
  const o = new google.auth.OAuth2(
    process.env.GOOGLE_CLIENT_ID,
    process.env.GOOGLE_CLIENT_SECRET
  );
  o.setCredentials({ refresh_token: process.env.GOOGLE_REFRESH_TOKEN });
  return o;
}
function calendar() { return google.calendar({ version: 'v3', auth: oauthClient() }); }
function gmail() { return google.gmail({ version: 'v1', auth: oauthClient() }); }
function drive() { return google.drive({ version: 'v3', auth: oauthClient() }); }

// ===== CORS =====
function getAllowedOrigin(event) {
  const origin = event?.headers?.origin || event?.headers?.Origin || '';
  const allow = String(process.env.CORS_ALLOW_ORIGINS || '').trim();
  if (!allow) return origin || '*';
  const allowed = allow.split(',').map(s => s.trim()).filter(Boolean);
  if (!origin) return allowed[0] || '*';
  return allowed.includes(origin) ? origin : (allowed[0] || '*');
}
function corsHeaders(event) {
  const origin = getAllowedOrigin(event);
  return {
    'Access-Control-Allow-Origin': origin,
    'Vary': 'Origin',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization, x-cron-secret',
    'Access-Control-Allow-Methods': 'GET,POST,OPTIONS',
    'Access-Control-Max-Age': '86400',
  };
}
function json(event, statusCode, body) {
  return {
    statusCode,
    headers: { ...corsHeaders(event), 'Content-Type': 'application/json' },
    body: JSON.stringify(body),
  };
}
function withCors(handler) {
  return async (event, context) => {
    if (event.httpMethod === 'OPTIONS') {
      return { statusCode: 204, headers: corsHeaders(event), body: '' };
    }
    try {
      const res = await handler(event, context);
      res.headers = { ...corsHeaders(event), ...(res.headers || {}) };
      return res;
    } catch (e) {
      console.error('Function crashed:', e);
      return json(event, 500, { ok: false, error: e.message || String(e) });
    }
  };
}

// ===== Timezone-safe date helpers (IST) =====
const IST_TZ = 'Asia/Kolkata';

function ymdInTZ(date, timeZone) {
  const parts = new Intl.DateTimeFormat('en-CA', {
    timeZone, year: 'numeric', month: '2-digit', day: '2-digit',
  }).formatToParts(date);
  const m = Object.fromEntries(parts.map(p => [p.type, p.value]));
  return `${m.year}-${m.month}-${m.day}`;
}
function ymdIST(date) { return ymdInTZ(date, IST_TZ); }

function dmyToYmd(dmyStr) {
  const s = String(dmyStr || '').trim();
  const m = /^(\d{2})-(\d{2})-(\d{4})$/.exec(s);
  if (!m) throw new Error(`Invalid date format "${s}". Expected DD-MM-YYYY`);
  const dd = m[1], mm = m[2], yyyy = m[3];
  const iso = `${yyyy}-${mm}-${dd}`;
  const dt = new Date(`${iso}T00:00:00Z`);
  if (Number.isNaN(dt.getTime())) throw new Error(`Invalid date: ${s}`);
  const check = dt.toISOString().slice(0, 10);
  if (check !== iso) throw new Error(`Invalid date: ${s}`);
  return iso;
}
function ymdToDmy(ymdStr) {
  if (!ymdStr) return '';
  const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(String(ymdStr).trim());
  if (!m) return '';
  return `${m[3]}-${m[2]}-${m[1]}`;
}

function addDays(date, days) {
  const d = new Date(date);
  d.setUTCDate(d.getUTCDate() + days);
  return d;
}
function dateFromYmdIST(ymdStr) {
  return new Date(`${ymdStr}T00:00:00+05:30`);
}
function addInterval(baseDate, recurrence, i) {
  const d = new Date(baseDate);
  if (i === 0) return d;
  const r = String(recurrence || 'AD_HOC').toUpperCase();
  if (r === 'DAILY') d.setUTCDate(d.getUTCDate() + i);
  else if (r === 'WEEKLY') d.setUTCDate(d.getUTCDate() + i * 7);
  else if (r === 'BIWEEKLY') d.setUTCDate(d.getUTCDate() + i * 14);
  else if (r === 'MONTHLY') d.setUTCMonth(d.getUTCMonth() + i);
  else if (r === 'BIMONTHLY') d.setUTCMonth(d.getUTCMonth() + i * 2);
  else if (r === 'QUARTERLY') d.setUTCMonth(d.getUTCMonth() + i * 3);
  else if (r === 'HALF_YEARLY') d.setUTCMonth(d.getUTCMonth() + i * 6);
  else if (r === 'YEARLY') d.setUTCFullYear(d.getUTCFullYear() + i);
  else d.setUTCDate(d.getUTCDate() + i);
  return d;
}

// ===== Settings: calendar window =====
async function getCalendarWindow() {
  const defaults = { startHH: 10, endHH: 12, timeZone: IST_TZ };
  try {
    const snap = await db().collection('settings').doc('calendar').get();
    if (!snap.exists) return defaults;
    const s = snap.data() || {};
    return {
      startHH: Number.isFinite(Number(s.startHH)) ? Number(s.startHH) : defaults.startHH,
      endHH: Number.isFinite(Number(s.endHH)) ? Number(s.endHH) : defaults.endHH,
      timeZone: s.timeZone || defaults.timeZone,
    };
  } catch {
    return defaults;
  }
}
function calTimeRange(ymdStr, startHH = 10, endHH = 12, timeZone = IST_TZ) {
  return {
    start: { dateTime: `${ymdStr}T${String(startHH).padStart(2, '0')}:00:00`, timeZone },
    end: { dateTime: `${ymdStr}T${String(endHH).padStart(2, '0')}:00:00`, timeZone },
  };
}

// ===== Audit =====
async function auditLog({ taskId, action, actorUid, actorEmail, details }) {
  await db().collection('auditLogs').add({
    taskId: taskId || null,
    action,
    actorUid: actorUid || null,
    actorEmail: actorEmail || null,
    timestamp: admin.firestore.FieldValue.serverTimestamp(),
    details: details || {}
  });
}

// ===== Email helpers =====
function asEmailList(x) {
  if (Array.isArray(x)) return x.map(s => String(s).trim()).filter(Boolean);
  if (typeof x === 'string') return x.split(/[;,:]/).map(s => s.trim()).filter(Boolean);
  return [];
}
function uniqEmails(arr) {
  const out = [];
  const seen = new Set();
  for (const e of (arr || [])) {
    const v = String(e || '').trim();
    if (!v) continue;
    const k = v.toLowerCase();
    if (seen.has(k)) continue;
    seen.add(k);
    out.push(v);
  }
  return out;
}
function escapeHtml(s) {
  return String(s || '')
    .replaceAll('&', '&amp;')
    .replaceAll('<', '&lt;')
    .replaceAll('>', '&gt;')
    .replaceAll('"', '&quot;')
    .replaceAll("'", '&#039;');
}

// NEW: token expansion (supports \\n tokens stored in Firestore)
function expandNewlineTokens(s) {
  let x = String(s ?? '');
  x = x.replaceAll('\\r\\n', '\n');
  x = x.replaceAll('\\n', '\n');
  return x;
}
function normalizeBodyToHtml(body) {
  let str = expandNewlineTokens(body);
  // If it already contains HTML tags, assume rich text
  if (/<[a-z][\s\S]*>/i.test(str)) return str;
  return escapeHtml(str).replace(/\r?\n/g, '<br>');
}
function renderTemplate(str, vars) {
  let out = String(str || '');
  for (const [k, v] of Object.entries(vars || {})) {
    out = out.replaceAll(`{{${k}}}`, v == null ? '' : String(v));
  }
  return out;
}

function buildRawEmail({ from, to, cc = [], bcc = [], subject, html, inReplyTo, references }) {
  const safeFrom = from || process.env.BOT_FROM || process.env.BOT_EMAIL || '';
  if (!safeFrom) throw new Error('BOT_FROM or BOT_EMAIL env var is missing');
  const subj = String(subject || '').replace(/\r?\n/g, ' ').trim();
  const lines = [
    `From: ${safeFrom}`,
    `To: ${to.join(', ')}`,
    cc.length ? `Cc: ${cc.join(', ')}` : null,
    bcc.length ? `Bcc: ${bcc.join(', ')}` : null,
    `Subject: ${subj}`,
    `Date: ${new Date().toUTCString()}`,
    inReplyTo ? `In-Reply-To: ${inReplyTo}` : null,
    references ? `References: ${references}` : null,
    'MIME-Version: 1.0',
    'Content-Type: text/html; charset="UTF-8"',
    '',
    html || ''
  ];
  const msg = lines.filter(x => x !== null).join('\r\n');
  return Buffer.from(msg).toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}

async function getMessageHeaders(gmailMessageId, headerNames = ['Message-ID', 'References']) {
  if (!gmailMessageId) return {};
  const g = gmail();
  const res = await g.users.messages.get({
    userId: 'me',
    id: gmailMessageId,
    format: 'metadata',
    metadataHeaders: headerNames,
  });
  const hdrs = res.data?.payload?.headers || [];
  const out = {};
  for (const h of hdrs) {
    const name = String(h.name || '').toLowerCase();
    out[name] = h.value || '';
  }
  return out;
}

async function sendEmail({ to, cc = [], bcc = [], subject, html }) {
  const toU = uniqEmails(to);
  const ccU = uniqEmails(cc);
  const bccU = uniqEmails(bcc);
  if (!toU.length) return null;

  const g = gmail();
  const raw = buildRawEmail({
    from: process.env.BOT_FROM,
    to: toU,
    cc: ccU,
    bcc: bccU,
    subject,
    html: normalizeBodyToHtml(html),
  });

  const sent = await g.users.messages.send({ userId: 'me', requestBody: { raw } });
  const gmailId = sent.data?.id || null;
  const threadId = sent.data?.threadId || null;

  let rfcMessageId = null;
  let references = null;
  try {
    if (gmailId) {
      const hdr = await getMessageHeaders(gmailId, ['Message-ID', 'References']);
      rfcMessageId = hdr['message-id'] || null;
      references = hdr['references'] || null;
    }
  } catch (e) {
    console.warn('Could not fetch headers. Continuing.', e?.message || e);
  }

  return { gmailId, threadId, rfcMessageId, references };
}

async function sendEmailReply({ threadId, inReplyTo, references, to, cc = [], bcc = [], subject, html }) {
  const toU = uniqEmails(to);
  const ccU = uniqEmails(cc);
  const bccU = uniqEmails(bcc);
  if (!toU.length) return null;

  if (!threadId) {
    return sendEmail({ to: toU, cc: ccU, bcc: bccU, subject, html });
  }

  const g = gmail();
  const raw = buildRawEmail({
    from: process.env.BOT_FROM,
    to: toU,
    cc: ccU,
    bcc: bccU,
    subject,
    html: normalizeBodyToHtml(html),
    inReplyTo,
    references: references || inReplyTo || null,
  });

  const sent = await g.users.messages.send({ userId: 'me', requestBody: { raw, threadId } });
  const gmailId = sent.data?.id || null;
  const outThreadId = sent.data?.threadId || threadId;

  let rfcMessageId = null;
  let outReferences = null;
  try {
    if (gmailId) {
      const hdr = await getMessageHeaders(gmailId, ['Message-ID', 'References']);
      rfcMessageId = hdr['message-id'] || null;
      outReferences = hdr['references'] || null;
    }
  } catch (e) {
    console.warn('Could not fetch headers for reply. Continuing.', e?.message || e);
  }

  return { gmailId, threadId: outThreadId, rfcMessageId, references: outReferences || references || null };
}

async function driveUpload({ folderId, filename, mimeType, buffer }) {
  const d = drive();
  const res = await d.files.create({
    requestBody: { name: filename, parents: [folderId] },
    media: { mimeType, body: Readable.from(buffer) },
    fields: 'id, webViewLink, size, mimeType, name'
  });
  return res.data;
}

// Helper: Create single START event
async function createStartCalendarEvent({ title, clientId, startDateYmd, dueDateYmd, window }) {
  const cal = calendar();
  const range = calTimeRange(startDateYmd, window.startHH, window.endHH, window.timeZone);
  const res = await cal.events.insert({
    calendarId: 'primary',
    sendUpdates: 'none',
    requestBody: {
      summary: `START: ${title}`,
      description:
        `ClientId: ${clientId}\n` +
        `Start: ${ymdToDmy(startDateYmd)}\n` +
        `Due: ${ymdToDmy(dueDateYmd)}\n`,
      ...range
    }
  });
  return { calendarEventId: res.data.id, calendarHtmlLink: res.data.htmlLink || null };
}

function buildGoogleCalendarTemplateUrl({ title, startYmd, startHH, endHH, timeZone, details }) {
  const ymdToCompact = (s) => String(s).replaceAll('-', '');
  const hh2 = (h) => String(h).padStart(2, '0');
  const start = `${ymdToCompact(startYmd)}T${hh2(startHH)}0000`;
  const end = `${ymdToCompact(startYmd)}T${hh2(endHH)}0000`;
  const params = new URLSearchParams({
    action: 'TEMPLATE',
    text: title || 'Compliance Task',
    dates: `${start}/${end}`,
    ctz: timeZone || 'Asia/Kolkata',
    details: details || ''
  });
  return `https://calendar.google.com/calendar/render?${params.toString()}`;
}

// ===== Recipient logic (start + completion) =====
async function getManagerEmailForAssignee(assignedToUid) {
  if (!assignedToUid) return null;
  try {
    const snap = await db().collection('users').doc(assignedToUid).get();
    if (!snap.exists) return null;
    const u = snap.data() || {};
    return u.managerEmail || null;
  } catch {
    return null;
  }
}

/**
 * Resolve recipients for START email
 * - If sendClientStartMail === false: we DO NOT use client primary or task.clientToEmails
 * - But we still allow internal CC/BCC (client master + task overrides)
 * - Gmail requires To, so we promote first CC/BCC into To when needed
 */
async function resolveStartRecipients({ client, task }) {
  const sendClientStartMail = (task.sendClientStartMail !== false);

  const taskTo = Array.isArray(task.clientToEmails) ? task.clientToEmails : [];
  const taskCc = Array.isArray(task.clientCcEmails) ? task.clientCcEmails : [];
  const taskBcc = Array.isArray(task.clientBccEmails) ? task.clientBccEmails : [];

  const baseClientTo = (client.primaryEmail ? [client.primaryEmail] : []);
  const baseClientCc = Array.isArray(client.ccEmails) ? client.ccEmails : [];
  const baseClientBcc = Array.isArray(client.bccEmails) ? client.bccEmails : [];

  let to = [];
  if (sendClientStartMail) {
    to = taskTo.length ? taskTo : baseClientTo;
  } else {
    to = []; // explicitly none
  }

  const cc = uniqEmails([...(baseClientCc || []), ...(taskCc || [])]);
  const bcc = uniqEmails([...(baseClientBcc || []), ...(taskBcc || [])]);

  // Optional CC assignee/manager on start
  if (task.ccAssigneeOnClientStart === true && task.assignedToEmail) cc.push(task.assignedToEmail);
  if (task.ccManagerOnClientStart === true && task.assignedToUid) {
    const mgr = await getManagerEmailForAssignee(task.assignedToUid);
    if (mgr) cc.push(mgr);
  }

  to = uniqEmails(to);
  const ccU = uniqEmails(cc);
  const bccU = uniqEmails(bcc);

  // Promote CC/BCC into To if To is empty
  if (!to.length) {
    if (ccU.length) to = [ccU[0]];
    else if (bccU.length) to = [bccU[0]];
  }

  return { to: uniqEmails(to), cc: ccU, bcc: bccU, sendClientStartMail };
}

/**
 * Resolve recipients for COMPLETION email (reply-all behaviour + overrides)
 * Overrides are completionToEmails/completionCcEmails/completionBccEmails.
 * If completionToEmails empty -> fallback to start logic's To (client primary / task start To)
 * Always include internal trail toggles: ccAssigneeOnCompletion / ccManagerOnCompletion.
 */
async function resolveCompletionRecipients({ client, task }) {
  const compTo = Array.isArray(task.completionToEmails) ? task.completionToEmails : [];
  const compCc = Array.isArray(task.completionCcEmails) ? task.completionCcEmails : [];
  const compBcc = Array.isArray(task.completionBccEmails) ? task.completionBccEmails : [];

  let { to, cc, bcc } = await resolveStartRecipients({ client, task });
  // For completion we should not respect sendClientStartMail; completion is separate flag
  // We'll fallback to start-based recipients only when completion override missing.

  const finalTo = compTo.length ? uniqEmails(compTo) : uniqEmails(to);
  const finalCc = uniqEmails([...(cc || []), ...(compCc || [])]);
  const finalBcc = uniqEmails([...(bcc || []), ...(compBcc || [])]);

  if (task.ccAssigneeOnCompletion === true && task.assignedToEmail) finalCc.push(task.assignedToEmail);
  if (task.ccManagerOnCompletion === true && task.assignedToUid) {
    const mgr = await getManagerEmailForAssignee(task.assignedToUid);
    if (mgr) finalCc.push(mgr);
  }

  const toU = uniqEmails(finalTo);
  const ccU = uniqEmails(finalCc);
  const bccU = uniqEmails(finalBcc);

  // Promote CC/BCC into To if To is empty (Gmail requirement)
  let toOut = toU;
  if (!toOut.length) {
    if (ccU.length) toOut = [ccU[0]];
    else if (bccU.length) toOut = [bccU[0]];
  }

  return { to: uniqEmails(toOut), cc: ccU, bcc: bccU };
}

// ===== Start mail send helper (shared by create/import) =====
async function trySendStartMailImmediately({ task, client, window }) {
  if (!task.clientStartSubject && !task.clientStartBody) return null;

  const recipients = await resolveStartRecipients({ client, task });
  if (!recipients.to.length) return null;

  const addToCalendarUrl = buildGoogleCalendarTemplateUrl({
    title: `START: ${task.title || 'Task'}`,
    startYmd: task.startDateYmd,
    startHH: window.startHH,
    endHH: window.endHH,
    timeZone: window.timeZone,
    details:
      `Client: ${client.name || ''}\n` +
      `Task: ${task.title || ''}\n` +
      `Start: ${ymdToDmy(task.startDateYmd)}\n` +
      `Due: ${ymdToDmy(task.dueDateYmd)}\n`
  });

  const vars = {
    clientName: client.name || '',
    taskTitle: task.title || '',
    startDate: ymdToDmy(task.startDateYmd),
    dueDate: ymdToDmy(task.dueDateYmd),
    addToCalendarUrl
  };

  const subject = renderTemplate(task.clientStartSubject || `We started {{taskTitle}}`, vars);
  const baseBody = renderTemplate(
    task.clientStartBody || `Dear {{clientName}},\n\nWe started work on {{taskTitle}}.\nDue: {{dueDate}}\n\nRegards,\nCompliance Team`,
    vars
  );
  const appended = `${baseBody}\n\n---\nAdd to your Google Calendar:\n${addToCalendarUrl}`;

  const mailRes = await sendEmail({
    to: recipients.to,
    cc: recipients.cc,
    bcc: recipients.bcc,
    subject,
    html: appended
  });

  return {
    clientStartMailSent: true,
    clientStartMailSentAt: admin.firestore.FieldValue.serverTimestamp(),
    clientStartGmailThreadId: mailRes?.threadId || null,
    clientStartGmailId: mailRes?.gmailId || null,
    clientStartRfcMessageId: mailRes?.rfcMessageId || null,
    clientStartReferences: mailRes?.references || null
  };
}

module.exports = {
  admin, db, auth, calendar, gmail, drive,
  withCors, json,
  IST_TZ,
  ymdInTZ, ymdIST, dmyToYmd, ymdToDmy,
  dateFromYmdIST, addDays, addInterval,
  getCalendarWindow, calTimeRange,
  auditLog,
  asEmailList, uniqEmails,
  renderTemplate,
  sendEmail, sendEmailReply,
  driveUpload,
  createStartCalendarEvent,
  trySendStartMailImmediately,
  expandNewlineTokens,
  // NEW exports
  resolveStartRecipients,
  resolveCompletionRecipients,
  getManagerEmailForAssignee,
  buildGoogleCalendarTemplateUrl
};

       --- File Content End ---


    =� clients_create.js

       --- File Content Start ---

const { withCors, json, db, admin, auditLog } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');

function asEmailList(x) {
  if (Array.isArray(x)) return x.map(s => String(s).trim()).filter(Boolean);
  if (typeof x === 'string') return x.split(/[;,]/).map(s => s.trim()).filter(Boolean);
  return [];
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const body = JSON.parse(event.body || '{}');

  const ref = db().collection('clients').doc();
  await ref.set({
    name: body.name || '',
    pan: body.pan || '',
    gstin: body.gstin || '',
    cin: body.cin || '',
    assessmentYear: body.assessmentYear || body.ay || '',
    engagementType: body.engagementType || body.eng || '',
    primaryEmail: body.primaryEmail || body.email || '',
    ccEmails: asEmailList(body.ccEmails || body.cc),
    bccEmails: asEmailList(body.bccEmails || body.bcc),
    driveFolderId: null,
    createdAt: admin.firestore.FieldValue.serverTimestamp()
  });

  await auditLog({ action:'CLIENT_CREATED', actorUid:user.uid, actorEmail:user.email, details:{ clientId: ref.id } });
  return json(event, 200, { ok:true, clientId: ref.id });
});

       --- File Content End ---


    =� clients_update.js

       --- File Content Start ---

// netlify/functions/clients_update.js
const { withCors, json, db, admin, auditLog } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');

function asEmailList(x) {
  if (Array.isArray(x)) return x.map(s => String(s).trim()).filter(Boolean);
  if (typeof x === 'string') return x.split(/[;,:]/).map(s => s.trim()).filter(Boolean);
  return [];
}

function cleanStr(x) {
  return String(x ?? '').trim();
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const body = JSON.parse(event.body || '{}');
  const clientId = cleanStr(body.clientId);
  if (!clientId) return json(event, 400, { ok:false, error:'clientId required' });

  const ref = db().collection('clients').doc(clientId);
  const snap = await ref.get();
  if (!snap.exists) return json(event, 404, { ok:false, error:'Client not found' });

  const patch = {
    name: cleanStr(body.name),
    pan: cleanStr(body.pan),
    gstin: cleanStr(body.gstin),
    cin: cleanStr(body.cin),
    assessmentYear: cleanStr(body.assessmentYear || body.ay),
    engagementType: cleanStr(body.engagementType || body.eng),
    primaryEmail: cleanStr(body.primaryEmail || body.email),
    ccEmails: asEmailList(body.ccEmails || body.cc),
    bccEmails: asEmailList(body.bccEmails || body.bcc),
    updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    updatedBy: user.email
  };

  await ref.set(patch, { merge: true });

  await auditLog({
    taskId: null,
    action: 'CLIENT_UPDATED',
    actorUid: user.uid,
    actorEmail: user.email,
    details: { clientId }
  });

  return json(event, 200, { ok:true, clientId });
});

       --- File Content End ---


    =� exports_clientHistoryXlsx.js

       --- File Content Start ---

// netlify/functions/exports_clientHistoryXlsx.js
const { withCors, json, db, ymdToDmy, IST_TZ } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');
const ExcelJS = require('exceljs');

function tsToIstString(ts) {
  if (!ts || !ts.toDate) return '';
  return ts.toDate().toLocaleString('en-IN', { timeZone: IST_TZ });
}

function xstr(v) {
  if (v == null) return '';
  if (typeof v === 'string') return v;
  if (typeof v === 'number' || typeof v === 'boolean') return String(v);
  try { return JSON.stringify(v); } catch { return String(v); }
}

function joinEmails(arr) {
  return Array.isArray(arr) ? arr.filter(Boolean).join(';') : '';
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;

  const { user } = authRes;
  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const body = JSON.parse(event.body || '{}');
  const clientId = String(body.clientId || '').trim();
  const fromYmd = String(body.fromYmd || '').trim();
  const toYmd = String(body.toYmd || '').trim();

  if (!clientId || !fromYmd || !toYmd) {
    return json(event, 400, { ok:false, error:'clientId,fromYmd,toYmd required' });
  }
  if (!/^\d{4}-\d{2}-\d{2}$/.test(fromYmd) || !/^\d{4}-\d{2}-\d{2}$/.test(toYmd)) {
    return json(event, 400, { ok:false, error:'fromYmd/toYmd must be YYYY-MM-DD' });
  }

  const clientSnap = await db().collection('clients').doc(clientId).get();
  if (!clientSnap.exists) return json(event, 404, { ok:false, error:'Client not found' });

  const client = clientSnap.data() || {};

  const tasksSnap = await db().collection('tasks')
    .where('clientId', '==', clientId)
    .where('dueDateYmd', '>=', fromYmd)
    .where('dueDateYmd', '<=', toYmd)
    .limit(1500)
    .get();

  const tasks = tasksSnap.docs.map(d => ({ id: d.id, ...d.data() }))
    .sort((a, b) => String(a.dueDateYmd || '').localeCompare(String(b.dueDateYmd || '')));

  const wb = new ExcelJS.Workbook();
  wb.creator = 'Compliance Management';
  wb.created = new Date();

  const ws = wb.addWorksheet('ClientHistory');
  ws.views = [{ state: 'frozen', ySplit: 1 }];

  ws.addRow([
    'TaskId',
    'Client',
    'Title',
    'Category',
    'Type',
    'Priority',
    'Recurrence',
    'SeriesId',
    'Occurrence',

    'Start (DD-MM-YYYY)',
    'Due (DD-MM-YYYY)',
    'TriggerDays',

    'Status',
    'Assignee',
    'StatusNote',
    'DelayReason',
    'DelayNotes',
    'SnoozedUntil (DD-MM-YYYY)',

    'CompletedRequestedAt (IST)',
    'CompletedAt (IST)',

    'SendStartMail',
    'ClientTo',
    'ClientCC',
    'ClientBCC',
    'CcAssigneeOnStart',
    'CcManagerOnStart',
    'ClientStartSubject',
    'ClientStartBody',
    'ClientStartMailSentAt (IST)',
    'ClientStartThreadId',
    'ClientStartMessageId',
    'ClientStartReferences',

    'SendClientCompletionMail',
    'CompletionTo',
    'CompletionCC',
    'CompletionBCC',
    'CcAssigneeOnCompletion',
    'CcManagerOnCompletion',
    'ClientCompletionSubject',
    'ClientCompletionBody',

    'CalendarEventId',
    'AttachmentLinks',

    'CreatedAt (IST)',
    'UpdatedAt (IST)'
  ]);

  ws.getRow(1).font = { bold: true };
  ws.columns.forEach(c => (c.width = 22));
  ws.getColumn(2).width = 30;   // Client
  ws.getColumn(3).width = 42;   // Title
  ws.getColumn(28).width = 44;  // Start body
  ws.getColumn(39).width = 44;  // Completion body
  ws.getColumn(41).width = 55;  // Attachment links

  for (const t of tasks) {
    const occ = t.seriesId ? `${t.occurrenceIndex || ''}/${t.occurrenceTotal || ''}` : '';
    const attachLinks = Array.isArray(t.attachments)
      ? t.attachments.map(a => a.driveWebViewLink || '').filter(Boolean).join(' | ')
      : '';

    ws.addRow([
      xstr(t.id),
      xstr(client.name || ''),
      xstr(t.title || ''),
      xstr(t.category || ''),
      xstr(t.type || ''),
      xstr(t.priority || 'MEDIUM'),
      xstr(t.recurrence || ''),
      xstr(t.seriesId || ''),
      xstr(occ),

      xstr(ymdToDmy(t.startDateYmd)),
      xstr(ymdToDmy(t.dueDateYmd)),
      xstr(t.triggerDaysBefore ?? ''),

      xstr(t.status || ''),
      xstr(t.assignedToEmail || ''),
      xstr(t.statusNote || ''),
      xstr(t.delayReason || ''),
      xstr(t.delayNotes || ''),
      xstr(ymdToDmy(t.snoozedUntilYmd)),

      xstr(tsToIstString(t.completedRequestedAt)),
      xstr(tsToIstString(t.completedAt)),

      xstr((t.sendClientStartMail === false) ? 'false' : 'true'),
      xstr(joinEmails(t.clientToEmails)),
      xstr(joinEmails(t.clientCcEmails)),
      xstr(joinEmails(t.clientBccEmails)),
      xstr(t.ccAssigneeOnClientStart === true ? 'true' : 'false'),
      xstr(t.ccManagerOnClientStart === true ? 'true' : 'false'),
      xstr(t.clientStartSubject || ''),
      xstr(t.clientStartBody || ''),
      xstr(tsToIstString(t.clientStartMailSentAt)),
      xstr(t.clientStartGmailThreadId || ''),
      xstr(t.clientStartRfcMessageId || ''),
      xstr(t.clientStartReferences || ''),

      xstr((t.sendClientCompletionMail === false) ? 'false' : 'true'),
      xstr(joinEmails(t.completionToEmails)),
      xstr(joinEmails(t.completionCcEmails)),
      xstr(joinEmails(t.completionBccEmails)),
      xstr(t.ccAssigneeOnCompletion === true ? 'true' : 'false'),
      xstr(t.ccManagerOnCompletion === true ? 'true' : 'false'),
      xstr(t.clientCompletionSubject || ''),
      xstr(t.clientCompletionBody || ''),

      xstr(t.calendarEventId || t.calendarStartEventId || ''),
      xstr(attachLinks),

      xstr(tsToIstString(t.createdAt)),
      xstr(tsToIstString(t.updatedAt))
    ]);
  }

  const buf = await wb.xlsx.writeBuffer();

  const safeClient = String(client.name || 'client')
    .replace(/[^\w\- ]+/g, '')
    .slice(0, 50)
    .trim() || 'client';

  return json(event, 200, {
    ok: true,
    fileName: `${safeClient}_history_${ymdToDmy(fromYmd)}_to_${ymdToDmy(toYmd)}.xlsx`,
    base64: Buffer.from(buf).toString('base64')
  });
});

       --- File Content End ---


    =� exports_firmRangeWithHistoryXlsx.js

       --- File Content Start ---

// netlify/functions/exports_firmRangeWithHistoryXlsx.js
const { withCors, json, db, dmyToYmd, ymdToDmy, IST_TZ } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');
const ExcelJS = require('exceljs');

function mustYmdFromInput({ fromDmy, toDmy, fromYmd, toYmd }) {
  const pick = (x) => (x == null ? '' : String(x).trim());
  if (pick(fromDmy) && pick(toDmy)) return { fromY: dmyToYmd(fromDmy), toY: dmyToYmd(toDmy) };
  if (pick(fromYmd) && pick(toYmd)) return { fromY: pick(fromYmd), toY: pick(toYmd) };
  throw new Error('Provide fromDmy & toDmy (DD-MM-YYYY) or fromYmd & toYmd (YYYY-MM-DD)');
}
function tsToIstString(ts) {
  if (!ts || !ts.toDate) return '';
  return ts.toDate().toLocaleString('en-IN', { timeZone: IST_TZ });
}
async function loadClientsMap(clientIds) {
  const ids = [...new Set((clientIds || []).filter(Boolean))];
  const map = new Map();
  if (!ids.length) return map;
  const refs = ids.map(id => db().collection('clients').doc(id));
  const snaps = await db().getAll(...refs);
  snaps.forEach(s => { if (s.exists) map.set(s.id, s.data()); });
  return map;
}
function xstr(v) {
  if (v == null) return '';
  if (typeof v === 'string') return v;
  if (typeof v === 'number' || typeof v === 'boolean') return String(v);
  try { return JSON.stringify(v); } catch { return String(v); }
}
function joinEmails(arr) {
  return Array.isArray(arr) ? arr.filter(Boolean).join(';') : '';
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;

  const { user } = authRes;
  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const body = JSON.parse(event.body || '{}');
  let fromY, toY;
  try { ({ fromY, toY } = mustYmdFromInput(body)); }
  catch (e) { return json(event, 400, { ok:false, error: e.message }); }

  const limitTasks = Math.min(800, Math.max(10, Number(body.limitTasks || 400)));
  const includeAudit = body.includeAudit !== false;

  const clientId = body.clientId ? String(body.clientId) : null;
  const status = body.status ? String(body.status) : null;
  const assignedToEmail = body.assignedToEmail ? String(body.assignedToEmail) : null;

  let q = db().collection('tasks')
    .where('dueDateYmd', '>=', fromY)
    .where('dueDateYmd', '<=', toY);

  if (clientId) q = q.where('clientId', '==', clientId);
  if (status) q = q.where('status', '==', status);
  if (assignedToEmail) q = q.where('assignedToEmail', '==', assignedToEmail);

  const tasksSnap = await q.limit(limitTasks).get();
  const tasks = tasksSnap.docs.map(d => ({ id: d.id, ...d.data() }));
  const clientsMap = await loadClientsMap(tasks.map(t => t.clientId));

  const wb = new ExcelJS.Workbook();
  wb.creator = 'Compliance Management';
  wb.created = new Date();

  // ===== Tasks sheet =====
  const wsT = wb.addWorksheet('Tasks');
  wsT.views = [{ state: 'frozen', ySplit: 1 }];

  wsT.addRow([
    'TaskId','Client','Title','Category','Type','Priority','Recurrence',
    'SeriesId','Occurrence',
    'Start (DD-MM-YYYY)','Due (DD-MM-YYYY)',
    'Status','Assignee',
    'StatusNote','DelayReason','DelayNotes',
    'SnoozedUntil (DD-MM-YYYY)',
    'CompletedRequestedAt (IST)','CompletedAt (IST)',

    'SendStartMail',
    'ClientTo','ClientCC','ClientBCC',
    'CcAssigneeOnStart','CcManagerOnStart',
    'ClientStartSubject','ClientStartBody',
    'ClientStartMailSentAt (IST)','ClientStartThreadId','ClientStartMessageId','ClientStartReferences',

    'SendClientCompletionMail',
    'CompletionTo','CompletionCC','CompletionBCC',
    'CcAssigneeOnCompletion','CcManagerOnCompletion',
    'ClientCompletionSubject','ClientCompletionBody',

    'CalendarEventId',
    'AttachmentLinks',
    'CreatedAt (IST)','UpdatedAt (IST)'
  ]);

  wsT.getRow(1).font = { bold: true };
  wsT.columns.forEach(c => { c.width = 22; });
  wsT.getColumn(2).width = 30;
  wsT.getColumn(3).width = 42;
  wsT.getColumn(28).width = 42; // start body
  wsT.getColumn(38).width = 42; // completion body
  wsT.getColumn(40).width = 55; // attachments
  wsT.getColumn(41).width = 22;
  wsT.getColumn(42).width = 22;

  for (const t of tasks) {
    const c = clientsMap.get(t.clientId) || {};
    const occ = t.seriesId ? `${t.occurrenceIndex || ''}/${t.occurrenceTotal || ''}` : '';
    const attachLinks = Array.isArray(t.attachments)
      ? t.attachments.map(a => a.driveWebViewLink || '').filter(Boolean).join(' | ')
      : '';

    wsT.addRow([
      xstr(t.id),
      xstr(c.name || ''),
      xstr(t.title || ''),
      xstr(t.category || ''),
      xstr(t.type || ''),
      xstr(t.priority || 'MEDIUM'),
      xstr(t.recurrence || ''),
      xstr(t.seriesId || ''),
      xstr(occ),
      xstr(ymdToDmy(t.startDateYmd)),
      xstr(ymdToDmy(t.dueDateYmd)),
      xstr(t.status || ''),
      xstr(t.assignedToEmail || ''),
      xstr(t.statusNote || ''),
      xstr(t.delayReason || ''),
      xstr(t.delayNotes || ''),
      xstr(ymdToDmy(t.snoozedUntilYmd)),
      xstr(tsToIstString(t.completedRequestedAt)),
      xstr(tsToIstString(t.completedAt)),

      xstr((t.sendClientStartMail === false) ? 'false' : 'true'),
      xstr(joinEmails(t.clientToEmails)),
      xstr(joinEmails(t.clientCcEmails)),
      xstr(joinEmails(t.clientBccEmails)),
      xstr(t.ccAssigneeOnClientStart === true ? 'true' : 'false'),
      xstr(t.ccManagerOnClientStart === true ? 'true' : 'false'),
      xstr(t.clientStartSubject || ''),
      xstr(t.clientStartBody || ''),
      xstr(tsToIstString(t.clientStartMailSentAt)),
      xstr(t.clientStartGmailThreadId || ''),
      xstr(t.clientStartRfcMessageId || ''),
      xstr(t.clientStartReferences || ''),

      xstr((t.sendClientCompletionMail === false) ? 'false' : 'true'),
      xstr(joinEmails(t.completionToEmails)),
      xstr(joinEmails(t.completionCcEmails)),
      xstr(joinEmails(t.completionBccEmails)),
      xstr(t.ccAssigneeOnCompletion === true ? 'true' : 'false'),
      xstr(t.ccManagerOnCompletion === true ? 'true' : 'false'),
      xstr(t.clientCompletionSubject || ''),
      xstr(t.clientCompletionBody || ''),

      xstr(t.calendarEventId || t.calendarStartEventId || ''),
      xstr(attachLinks),
      xstr(tsToIstString(t.createdAt)),
      xstr(tsToIstString(t.updatedAt)),
    ]);
  }

  // ===== Audit sheet =====
  const wsA = wb.addWorksheet('AuditLogs');
  wsA.views = [{ state: 'frozen', ySplit: 1 }];
  wsA.addRow(['Time (IST)','Action','TaskId','ActorEmail','Details']);
  wsA.getRow(1).font = { bold: true };
  wsA.getColumn(1).width = 22;
  wsA.getColumn(2).width = 22;
  wsA.getColumn(3).width = 26;
  wsA.getColumn(4).width = 26;
  wsA.getColumn(5).width = 80;

  let auditRows = 0;
  const maxAuditRows = Math.min(5000, Math.max(200, Number(body.maxAuditRows || 2000)));

  if (includeAudit) {
    for (const t of tasks) {
      if (auditRows >= maxAuditRows) break;

      const aSnap = await db().collection('auditLogs').where('taskId', '==', t.id).get();
      const logs = aSnap.docs.map(d => d.data());
      logs.sort((x,y) => (x.timestamp?.toMillis?.()||0) - (y.timestamp?.toMillis?.()||0));

      for (const a of logs) {
        if (auditRows >= maxAuditRows) break;
        wsA.addRow([
          a.timestamp?.toDate?.() ? a.timestamp.toDate().toLocaleString('en-IN', { timeZone: IST_TZ }) : '',
          xstr(a.action || ''),
          xstr(a.taskId || ''),
          xstr(a.actorEmail || ''),
          xstr(a.details || {}),
        ]);
        auditRows++;
      }
    }
  }

  const buf = await wb.xlsx.writeBuffer();
  return json(event, 200, {
    ok: true,
    fileName: `firm_tasks_${ymdToDmy(fromY)}_to_${ymdToDmy(toY)}.xlsx`,
    meta: { tasks: tasks.length, auditRows, truncatedAudit: includeAudit && auditRows >= maxAuditRows },
    base64: Buffer.from(buf).toString('base64')
  });
});

       --- File Content End ---


    =� exports_myClientsTemplateXlsx.js

       --- File Content Start ---

// netlify/functions/exports_myClientsTemplateXlsx.js
const { withCors, json, db } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');
const ExcelJS = require('exceljs');

function col(n) {
  let s = '';
  while (n > 0) {
    const m = (n - 1) % 26;
    s = String.fromCharCode(65 + m) + s;
    n = Math.floor((n - 1) / 26);
  }
  return s;
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok: false, error: 'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;

  const { user } = authRes;
  const p = requirePartner(event, user);
  if (p.error) return p.error;

  // load clients
  const snap = await db().collection('clients').limit(400).get();
  const clients = snap.docs.map(d => ({ id: d.id, ...d.data() }));

  const wb = new ExcelJS.Workbook();
  wb.creator = 'Compliance Management';
  wb.created = new Date();

  const ws = wb.addWorksheet('Import');
  const lists = wb.addWorksheet('Lists');

  // Dropdown lists
  const categories = ['GST', 'TDS', 'Income Tax', 'ROC', 'Accounting', 'Audit', 'Other'];
  const recurrences = ['AD_HOC', 'DAILY', 'WEEKLY', 'BIWEEKLY', 'MONTHLY', 'BIMONTHLY', 'QUARTERLY', 'HALF_YEARLY', 'YEARLY'];
  const types = ['FILING', 'REVIEW', 'PAYMENT', 'FOLLOW_UP', 'CLIENT_PENDING'];
  const priorities = ['HIGH', 'MEDIUM', 'LOW'];

  lists.getCell('A1').value = 'Categories';
  categories.forEach((v, i) => (lists.getCell(`A${i + 2}`).value = v));

  lists.getCell('B1').value = 'Recurrences';
  recurrences.forEach((v, i) => (lists.getCell(`B${i + 2}`).value = v));

  lists.getCell('C1').value = 'Types';
  types.forEach((v, i) => (lists.getCell(`C${i + 2}`).value = v));

  lists.getCell('D1').value = 'Priorities';
  priorities.forEach((v, i) => (lists.getCell(`D${i + 2}`).value = v));

  lists.getCell('E1').value = 'Clients';
  const clientNames = clients
    .map(c => String(c.name || '').trim())
    .filter(Boolean)
    .sort((a, b) => a.localeCompare(b));
  clientNames.forEach((v, i) => (lists.getCell(`E${i + 2}`).value = v));

  lists.columns.forEach(c => (c.width = 24));
  lists.getColumn(5).width = 42;

  // Main sheet headers
  const headers = [
    'Title',
    'Client',
    'ClientEmail',
    'DueDate (DD-MM-YYYY)',
    'Category',
    'Type (you can type custom)',
    'Recurrence',
    'GenerateCount',
    'TriggerDays',
    'AssignedToEmail',
    'Priority',

    'SendStartMail (true/false)',
    'ClientTo (emails ; , : separated)',
    'ClientCC (emails ; , : separated)',
    'ClientBCC (emails ; , : separated)',
    'ClientStartSubject',
    'ClientStartBody',

    'SendClientCompletionMail (true/false)',
    'CompletionTo (emails ; , : separated)',
    'CompletionCC (emails ; , : separated)',
    'CompletionBCC (emails ; , : separated)',
    'CcAssigneeOnClientStart (true/false)',
    'CcManagerOnClientStart (true/false)',
    'CcAssigneeOnCompletion (true/false)',
    'CcManagerOnCompletion (true/false)',
    'ClientCompletionSubject',
    'ClientCompletionBody',
  ];

  ws.addRow(headers);
  ws.getRow(1).font = { bold: true };
  ws.views = [{ state: 'frozen', ySplit: 1 }];

  const widths = [
    34, 32, 28, 20, 18, 24, 16, 14, 12, 22, 12,
    18, 28, 28, 28, 30, 44,
    26, 28, 28, 28, 28, 28, 28, 28, 30, 44,
  ];
  ws.columns = headers.map((h, i) => ({ header: h, width: widths[i] || 22 }));

  // sample due date = today + 30 days
  const pad = (n) => String(n).padStart(2, '0');
  const d = new Date();
  d.setDate(d.getDate() + 30);
  const dueDmy = `${pad(d.getDate())}-${pad(d.getMonth() + 1)}-${d.getFullYear()}`;

  // sample rows
  const sampleRows = Math.min(30, clientNames.length);
  for (let i = 0; i < sampleRows; i++) {
    const cname = clientNames[i] || '';
    ws.addRow([
      `Sample Task for ${cname || 'Client'}`,
      cname,
      '',
      dueDmy,
      'Other',
      'FOLLOW_UP',
      'AD_HOC',
      1,
      7,
      '',
      'MEDIUM',

      'true',
      '',
      '',
      '',
      'We started working on {{taskTitle}}',
      `Dear {{clientName}},\n\nWe started work on {{taskTitle}}.\nDue: {{dueDate}}.\n\nAdd to calendar: {{addToCalendarUrl}}\n\nRegards,\nYour Firm`,

      'true',
      '',
      '',
      '',
      'false',
      'false',
      'false',
      'false',
      'Completed: {{taskTitle}}',
      `Dear {{clientName}},\n\nWe have completed {{taskTitle}}.\nCompleted at: {{completedAt}}\n\nRegards,\nYour Firm`,
    ]);
  }

  // Validations
  const maxRows = Math.max(150, sampleRows + 80);
  const catRange = `Lists!$A$2:$A$${categories.length + 1}`;
  const recRange = `Lists!$B$2:$B$${recurrences.length + 1}`;
  const typeRange = `Lists!$C$2:$C$${types.length + 1}`;
  const priRange = `Lists!$D$2:$D$${priorities.length + 1}`;
  const clientsRange = `Lists!$E$2:$E$${clientNames.length + 1}`;

  const COL_CLIENT = headers.indexOf('Client') + 1;
  const COL_CATEGORY = headers.indexOf('Category') + 1;
  const COL_TYPE = headers.indexOf('Type (you can type custom)') + 1;
  const COL_REC = headers.indexOf('Recurrence') + 1;
  const COL_PRIORITY = headers.indexOf('Priority') + 1;

  const COL_SENDSTART = headers.indexOf('SendStartMail (true/false)') + 1;
  const COL_SENDCOMP = headers.indexOf('SendClientCompletionMail (true/false)') + 1;

  const COL_CC_ASSIGNEE = headers.indexOf('CcAssigneeOnClientStart (true/false)') + 1;
  const COL_CC_MANAGER = headers.indexOf('CcManagerOnClientStart (true/false)') + 1;
  const COL_CC_ASSIGNEE_COMP = headers.indexOf('CcAssigneeOnCompletion (true/false)') + 1;
  const COL_CC_MANAGER_COMP = headers.indexOf('CcManagerOnCompletion (true/false)') + 1;

  const tfFormula = `"true,false"`;

  for (let r = 2; r <= maxRows; r++) {
    ws.getCell(`${col(COL_CLIENT)}${r}`).dataValidation = {
      type: 'list',
      allowBlank: true,
      formulae: [clientsRange],
      showErrorMessage: false
    };
    ws.getCell(`${col(COL_CATEGORY)}${r}`).dataValidation = {
      type: 'list',
      allowBlank: true,
      formulae: [catRange],
      showErrorMessage: true
    };
    ws.getCell(`${col(COL_REC)}${r}`).dataValidation = {
      type: 'list',
      allowBlank: true,
      formulae: [recRange],
      showErrorMessage: true
    };
    ws.getCell(`${col(COL_TYPE)}${r}`).dataValidation = {
      type: 'list',
      allowBlank: true,
      formulae: [typeRange],
      showErrorMessage: false
    };
    ws.getCell(`${col(COL_PRIORITY)}${r}`).dataValidation = {
      type: 'list',
      allowBlank: true,
      formulae: [priRange],
      showErrorMessage: true
    };

    ws.getCell(`${col(COL_SENDSTART)}${r}`).dataValidation = {
      type: 'list',
      allowBlank: true,
      formulae: [tfFormula],
      showErrorMessage: true
    };
    ws.getCell(`${col(COL_SENDCOMP)}${r}`).dataValidation = {
      type: 'list',
      allowBlank: true,
      formulae: [tfFormula],
      showErrorMessage: true
    };
    ws.getCell(`${col(COL_CC_ASSIGNEE)}${r}`).dataValidation = {
      type: 'list',
      allowBlank: true,
      formulae: [tfFormula],
      showErrorMessage: true
    };
    ws.getCell(`${col(COL_CC_MANAGER)}${r}`).dataValidation = {
      type: 'list',
      allowBlank: true,
      formulae: [tfFormula],
      showErrorMessage: true
    };
    ws.getCell(`${col(COL_CC_ASSIGNEE_COMP)}${r}`).dataValidation = {
      type: 'list',
      allowBlank: true,
      formulae: [tfFormula],
      showErrorMessage: true
    };
    ws.getCell(`${col(COL_CC_MANAGER_COMP)}${r}`).dataValidation = {
      type: 'list',
      allowBlank: true,
      formulae: [tfFormula],
      showErrorMessage: true
    };
  }

  const buf = await wb.xlsx.writeBuffer();
  return json(event, 200, {
    ok: true,
    fileName: `Client_Tasks_Import_Template.xlsx`,
    base64: Buffer.from(buf).toString('base64')
  });
});

       --- File Content End ---


    =� exports_quickXlsx.js

       --- File Content Start ---

// netlify/functions/exports_quickXlsx.js
const { withCors, json, db, ymdIST, addDays, dateFromYmdIST, ymdToDmy, IST_TZ } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');
const ExcelJS = require('exceljs');

function tsToIstString(ts) {
  if (!ts || !ts.toDate) return '';
  return ts.toDate().toLocaleString('en-IN', { timeZone: IST_TZ });
}
async function loadClientsMap(clientIds) {
  const ids = [...new Set((clientIds || []).filter(Boolean))];
  const map = new Map();
  if (!ids.length) return map;
  const refs = ids.map(id => db().collection('clients').doc(id));
  const snaps = await db().getAll(...refs);
  snaps.forEach(s => { if (s.exists) map.set(s.id, s.data()); });
  return map;
}
function xstr(v) {
  if (v == null) return '';
  if (typeof v === 'string') return v;
  if (typeof v === 'number' || typeof v === 'boolean') return String(v);
  try { return JSON.stringify(v); } catch { return String(v); }
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;

  const { user } = authRes;
  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const body = JSON.parse(event.body || '{}');
  const mode = String(body.mode || '').toUpperCase().trim();
  if (!mode) return json(event, 400, { ok:false, error:'mode required' });

  const todayYmd = ymdIST(new Date());
  let fromYmd = todayYmd;
  let toYmd = todayYmd;

  if (mode === 'NEXT_7') toYmd = ymdIST(addDays(dateFromYmdIST(todayYmd), 7));
  else if (mode === 'NEXT_15') toYmd = ymdIST(addDays(dateFromYmdIST(todayYmd), 15));
  else if (mode === 'NEXT_30') toYmd = ymdIST(addDays(dateFromYmdIST(todayYmd), 30));
  else if (mode === 'OVERDUE') { /* handled below */ }
  else if (mode === 'APPROVAL_PENDING') { /* handled below */ }
  else return json(event, 400, { ok:false, error:'Invalid mode' });

  let q = db().collection('tasks');

  if (mode === 'OVERDUE') {
    q = q.where('status', 'in', ['PENDING','IN_PROGRESS','CLIENT_PENDING','APPROVAL_PENDING'])
      .where('dueDateYmd', '<', todayYmd);
  } else if (mode === 'APPROVAL_PENDING') {
    q = q.where('status', '==', 'APPROVAL_PENDING');
  } else {
    q = q.where('status', 'in', ['PENDING','IN_PROGRESS','CLIENT_PENDING','APPROVAL_PENDING'])
      .where('dueDateYmd', '>=', fromYmd)
      .where('dueDateYmd', '<=', toYmd);
  }

  const snap = await q.limit(800).get();
  const tasks = snap.docs.map(d => ({ id:d.id, ...d.data() }));
  const clientsMap = await loadClientsMap(tasks.map(t => t.clientId));

  const wb = new ExcelJS.Workbook();
  wb.creator = 'Compliance Management';
  wb.created = new Date();

  const ws = wb.addWorksheet('Tasks');
  ws.views = [{ state: 'frozen', ySplit: 1 }];
  ws.addRow([
    'TaskId','Client','Title','Category','Type','Priority',
    'Start (DD-MM-YYYY)','Due (DD-MM-YYYY)',
    'Status','Assignee',
    'SnoozedUntil (DD-MM-YYYY)',
    'SendStartMail','SendCompletionMail',
    'StatusNote','DelayReason','DelayNotes',
    'CompletedAt (IST)','CalendarEventId'
  ]);
  ws.getRow(1).font = { bold: true };
  ws.columns.forEach(c => { c.width = 22; });
  ws.getColumn(2).width = 30;
  ws.getColumn(3).width = 42;

  tasks.sort((a,b)=>String(a.dueDateYmd||'').localeCompare(String(b.dueDateYmd||'')));

  for (const t of tasks) {
    const c = clientsMap.get(t.clientId) || {};
    ws.addRow([
      xstr(t.id),
      xstr(c.name || ''),
      xstr(t.title || ''),
      xstr(t.category || ''),
      xstr(t.type || ''),
      xstr(t.priority || 'MEDIUM'),
      xstr(ymdToDmy(t.startDateYmd)),
      xstr(ymdToDmy(t.dueDateYmd)),
      xstr(t.status || ''),
      xstr(t.assignedToEmail || ''),
      xstr(ymdToDmy(t.snoozedUntilYmd)),
      xstr((t.sendClientStartMail === false) ? 'false' : 'true'),
      xstr((t.sendClientCompletionMail === false) ? 'false' : 'true'),
      xstr(t.statusNote || ''),
      xstr(t.delayReason || ''),
      xstr(t.delayNotes || ''),
      xstr(tsToIstString(t.completedAt)),
      xstr(t.calendarEventId || t.calendarStartEventId || '')
    ]);
  }

  const buf = await wb.xlsx.writeBuffer();
  const label =
    mode === 'OVERDUE' ? `overdue_asof_${ymdToDmy(todayYmd)}` :
    mode === 'APPROVAL_PENDING' ? `approval_pending_${ymdToDmy(todayYmd)}` :
    `${ymdToDmy(fromYmd)}_to_${ymdToDmy(toYmd)}`;

  return json(event, 200, {
    ok: true,
    fileName: `quick_${mode.toLowerCase()}_${label}.xlsx`,
    count: tasks.length,
    base64: Buffer.from(buf).toString('base64')
  });
});

       --- File Content End ---


    =� exports_taskHistoryXlsx.js

       --- File Content Start ---

// netlify/functions/exports_taskHistoryXlsx.js
const { withCors, json, db, ymdToDmy, IST_TZ } = require('./_common');
const { requireUser } = require('./_auth');
const ExcelJS = require('exceljs');

function tsToIstString(ts) {
  if (!ts || !ts.toDate) return '';
  return ts.toDate().toLocaleString('en-IN', { timeZone: IST_TZ });
}
function xstr(v) {
  if (v == null) return '';
  if (typeof v === 'string') return v;
  if (typeof v === 'number' || typeof v === 'boolean') return String(v);
  try { return JSON.stringify(v); } catch { return String(v); }
}
function roleOf(user) {
  let r = String(user?.role || 'ASSOCIATE').toUpperCase().trim();
  if (r === 'WORKER') r = 'ASSOCIATE';
  return r || 'ASSOCIATE';
}
function isPrivileged(role) {
  return role === 'PARTNER' || role === 'MANAGER';
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const role = roleOf(user);
  const privileged = isPrivileged(role);

  const body = JSON.parse(event.body || '{}');
  const taskId = String(body.taskId || '').trim();
  if (!taskId) return json(event, 400, { ok:false, error:'taskId required' });

  const tSnap = await db().collection('tasks').doc(taskId).get();
  if (!tSnap.exists) return json(event, 404, { ok:false, error:'Task not found' });
  const task = tSnap.data();

  if (!privileged && task.assignedToUid !== user.uid) {
    return json(event, 403, { ok:false, error:'Not allowed' });
  }

  const clientSnap = task.clientId ? await db().collection('clients').doc(task.clientId).get() : null;
  const client = clientSnap && clientSnap.exists ? clientSnap.data() : {};

  const wb = new ExcelJS.Workbook();
  wb.creator = 'Compliance Management';
  wb.created = new Date();

  // Sheet: Task
  const wsT = wb.addWorksheet('Task');
  wsT.addRow(['Field','Value']);
  wsT.getRow(1).font = { bold: true };
  const addKV = (k, v) => wsT.addRow([k, xstr(v)]);

  addKV('TaskId', taskId);
  addKV('Client', client.name || '');
  addKV('Title', task.title || '');
  addKV('Category', task.category || '');
  addKV('Type', task.type || '');
  addKV('Priority', task.priority || '');
  addKV('Recurrence', task.recurrence || '');
  addKV('SeriesId', task.seriesId || '');
  addKV('Occurrence', task.seriesId ? `${task.occurrenceIndex || ''}/${task.occurrenceTotal || ''}` : '');
  addKV('Start (DD-MM-YYYY)', ymdToDmy(task.startDateYmd));
  addKV('Due (DD-MM-YYYY)', ymdToDmy(task.dueDateYmd));
  addKV('Status', task.status || '');
  addKV('Assignee', task.assignedToEmail || '');
  addKV('StatusNote', task.statusNote || '');
  addKV('DelayReason', task.delayReason || '');
  addKV('DelayNotes', task.delayNotes || '');
  addKV('SnoozedUntil', ymdToDmy(task.snoozedUntilYmd));
  addKV('StartMailSentAt (IST)', tsToIstString(task.clientStartMailSentAt));
  addKV('StartThreadId', task.clientStartGmailThreadId || '');
  addKV('SendCompletionMail', (task.sendClientCompletionMail === false) ? 'false' : 'true');
  addKV('CalendarEventId', task.calendarEventId || task.calendarStartEventId || '');
  addKV('CreatedAt (IST)', tsToIstString(task.createdAt));
  addKV('UpdatedAt (IST)', tsToIstString(task.updatedAt));

  wsT.getColumn(1).width = 28;
  wsT.getColumn(2).width = 80;

  // Sheet: AuditLogs
  const wsA = wb.addWorksheet('AuditLogs');
  wsA.views = [{ state: 'frozen', ySplit: 1 }];
  wsA.addRow(['Time (IST)','Action','ActorEmail','Details']);
  wsA.getRow(1).font = { bold: true };
  wsA.getColumn(1).width = 22;
  wsA.getColumn(2).width = 22;
  wsA.getColumn(3).width = 26;
  wsA.getColumn(4).width = 90;

  const aSnap = await db().collection('auditLogs').where('taskId', '==', taskId).get();
  const logs = aSnap.docs.map(d => d.data());
  logs.sort((x,y)=> (x.timestamp?.toMillis?.()||0) - (y.timestamp?.toMillis?.()||0));
  for (const a of logs) {
    wsA.addRow([
      a.timestamp?.toDate?.() ? a.timestamp.toDate().toLocaleString('en-IN', { timeZone: IST_TZ }) : '',
      xstr(a.action || ''),
      xstr(a.actorEmail || ''),
      xstr(a.details || {})
    ]);
  }

  // Sheet: Comments
  const wsC = wb.addWorksheet('Comments');
  wsC.views = [{ state: 'frozen', ySplit: 1 }];
  wsC.addRow(['Time (IST)','Author','Text']);
  wsC.getRow(1).font = { bold: true };
  wsC.getColumn(1).width = 22;
  wsC.getColumn(2).width = 26;
  wsC.getColumn(3).width = 90;

  const cSnap = await db().collection('tasks').doc(taskId).collection('comments')
    .orderBy('createdAt', 'asc')
    .limit(500)
    .get();
  cSnap.docs.forEach(d => {
    const c = d.data();
    wsC.addRow([
      c.createdAt?.toDate?.() ? c.createdAt.toDate().toLocaleString('en-IN', { timeZone: IST_TZ }) : '',
      (c.authorName || c.authorEmail || ''),
      xstr(c.text || '')
    ]);
  });

  // Sheet: Attachments
  const wsF = wb.addWorksheet('Attachments');
  wsF.views = [{ state: 'frozen', ySplit: 1 }];
  wsF.addRow(['Type','FileName','Link','UploadedBy','UploadedAt (IST)']);
  wsF.getRow(1).font = { bold: true };
  wsF.getColumn(1).width = 14;
  wsF.getColumn(2).width = 32;
  wsF.getColumn(3).width = 70;
  wsF.getColumn(4).width = 20;
  wsF.getColumn(5).width = 22;

  const att = Array.isArray(task.attachments) ? task.attachments : [];
  att.forEach(a => {
    wsF.addRow([
      xstr(a.type || ''),
      xstr(a.fileName || ''),
      xstr(a.driveWebViewLink || ''),
      xstr(a.uploadedByUid || ''),
      a.uploadedAt?.toDate?.() ? a.uploadedAt.toDate().toLocaleString('en-IN', { timeZone: IST_TZ }) : ''
    ]);
  });

  const buf = await wb.xlsx.writeBuffer();
  const safeTitle = String(task.title || 'task').replace(/[^\w\- ]+/g, '').slice(0, 40).trim() || 'task';

  return json(event, 200, {
    ok: true,
    fileName: `task_history_${safeTitle}_${taskId}.xlsx`,
    base64: Buffer.from(buf).toString('base64')
  });
});

       --- File Content End ---


    =� exports_tasksExportForUpdateXlsx.js

       --- File Content Start ---

// netlify/functions/exports_tasksExportForUpdateXlsx.js
const { withCors, json, db, ymdToDmy } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');
const ExcelJS = require('exceljs');

function xstr(v) {
  if (v == null) return '';
  if (typeof v === 'string') return v;
  if (typeof v === 'number' || typeof v === 'boolean') return String(v);
  try { return JSON.stringify(v); } catch { return String(v); }
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const body = JSON.parse(event.body || '{}');

  // Optional filters (to keep file manageable)
  const clientId = body.clientId ? String(body.clientId) : null;
  const status = body.status ? String(body.status) : null;
  const assignedToEmail = body.assignedToEmail ? String(body.assignedToEmail) : null;

  const limitTasks = Math.min(1200, Math.max(10, Number(body.limitTasks || 600)));

  let q = db().collection('tasks');
  if (clientId) q = q.where('clientId', '==', clientId);
  if (status) q = q.where('status', '==', status);
  if (assignedToEmail) q = q.where('assignedToEmail', '==', assignedToEmail);

  const snap = await q.limit(limitTasks).get();
  const tasks = snap.docs.map(d => ({ id: d.id, ...d.data() }))
    .sort((a,b)=>String(a.dueDateYmd||'').localeCompare(String(b.dueDateYmd||'')));

  const wb = new ExcelJS.Workbook();
  wb.creator = 'Compliance Management';
  wb.created = new Date();

  const ws = wb.addWorksheet('Update');
  ws.views = [{ state: 'frozen', ySplit: 1 }];

  const headers = [
    'TaskId',
    'Title',
    'Category',
    'Type',
    'Priority',
    'DueDate (DD-MM-YYYY)',
    'TriggerDays',
    'AssignedToEmail',
    'Status',
    'StatusNote',
    'DelayReason',
    'DelayNotes',
    'SnoozedUntil (DD-MM-YYYY)',
    'SendStartMail (true/false)',
    'ClientTo (emails ; , : separated)',
    'ClientCC (emails ; , : separated)',
    'ClientBCC (emails ; , : separated)',
    'CcAssigneeOnClientStart (true/false)',
    'CcManagerOnClientStart (true/false)',
    'ClientStartSubject',
    'ClientStartBody',
    'SendClientCompletionMail (true/false)',
    'CompletionTo (emails ; , : separated)',
    'CompletionCC (emails ; , : separated)',
    'CompletionBCC (emails ; , : separated)',
    'CcAssigneeOnCompletion (true/false)',
    'CcManagerOnCompletion (true/false)',
    'ClientCompletionSubject',
    'ClientCompletionBody',
  ];

  ws.addRow(headers);
  ws.getRow(1).font = { bold: true };

  ws.columns = [
    { width: 26 }, { width: 36 }, { width: 16 }, { width: 20 }, { width: 12 },
    { width: 20 }, { width: 12 }, { width: 26 }, { width: 18 }, { width: 36 },
    { width: 16 }, { width: 32 }, { width: 22 },
    { width: 18 }, { width: 28 }, { width: 28 }, { width: 28 },
    { width: 22 }, { width: 22 },
    { width: 30 }, { width: 44 },
    { width: 26 }, { width: 28 }, { width: 28 }, { width: 28 },
    { width: 26 }, { width: 26 },
    { width: 30 }, { width: 44 },
  ];

  for (const t of tasks) {
    ws.addRow([
      xstr(t.id),
      xstr(t.title || ''),
      xstr(t.category || ''),
      xstr(t.type || ''),
      xstr(t.priority || 'MEDIUM'),
      xstr(ymdToDmy(t.dueDateYmd)),
      xstr(t.triggerDaysBefore ?? t.triggerDaysBefore ?? t.triggerDaysBefore), // keep simple if field missing
      xstr(t.assignedToEmail || ''),
      xstr(t.status || ''),
      xstr(t.statusNote || ''),
      xstr(t.delayReason || ''),
      xstr(t.delayNotes || ''),
      xstr(ymdToDmy(t.snoozedUntilYmd)),
      xstr((t.sendClientStartMail === false) ? 'false' : 'true'),
      xstr(Array.isArray(t.clientToEmails) ? t.clientToEmails.join(';') : ''),
      xstr(Array.isArray(t.clientCcEmails) ? t.clientCcEmails.join(';') : ''),
      xstr(Array.isArray(t.clientBccEmails) ? t.clientBccEmails.join(';') : ''),
      xstr(t.ccAssigneeOnClientStart === true ? 'true' : 'false'),
      xstr(t.ccManagerOnClientStart === true ? 'true' : 'false'),
      xstr(t.clientStartSubject || ''),
      xstr(t.clientStartBody || ''),
      xstr((t.sendClientCompletionMail === false) ? 'false' : 'true'),
      xstr(Array.isArray(t.completionToEmails) ? t.completionToEmails.join(';') : ''),
      xstr(Array.isArray(t.completionCcEmails) ? t.completionCcEmails.join(';') : ''),
      xstr(Array.isArray(t.completionBccEmails) ? t.completionBccEmails.join(';') : ''),
      xstr(t.ccAssigneeOnCompletion === true ? 'true' : 'false'),
      xstr(t.ccManagerOnCompletion === true ? 'true' : 'false'),
      xstr(t.clientCompletionSubject || ''),
      xstr(t.clientCompletionBody || ''),
    ]);
  }

  const buf = await wb.xlsx.writeBuffer();
  return json(event, 200, {
    ok: true,
    fileName: `tasks_export_for_update.xlsx`,
    count: tasks.length,
    base64: Buffer.from(buf).toString('base64')
  });
});

       --- File Content End ---


    =� exports_tasksUpdateTemplateXlsx.js

       --- File Content Start ---

// netlify/functions/exports_tasksUpdateTemplateXlsx.js
const { withCors, json, db } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');
const ExcelJS = require('exceljs');

function col(n) {
  let s = '';
  while (n > 0) {
    const m = (n - 1) % 26;
    s = String.fromCharCode(65 + m) + s;
    n = Math.floor((n - 1) / 26);
  }
  return s;
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;

  const { user } = authRes;
  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const wb = new ExcelJS.Workbook();
  wb.creator = 'Compliance Management';
  wb.created = new Date();

  const ws = wb.addWorksheet('Update');
  const lists = wb.addWorksheet('Lists');

  const statuses = ['PENDING','IN_PROGRESS','CLIENT_PENDING','APPROVAL_PENDING','COMPLETED'];
  const categories = ['GST', 'TDS', 'INCOME_TAX', 'ROC', 'ACCOUNTING', 'AUDIT', 'OTHER'];
  const priorities = ['HIGH','MEDIUM','LOW'];
  const tf = ['true','false'];

  lists.getCell('A1').value = 'Statuses';
  statuses.forEach((v, i) => (lists.getCell(`A${i + 2}`).value = v));
  lists.getCell('B1').value = 'Categories';
  categories.forEach((v, i) => (lists.getCell(`B${i + 2}`).value = v));
  lists.getCell('C1').value = 'Priorities';
  priorities.forEach((v, i) => (lists.getCell(`C${i + 2}`).value = v));
  lists.getCell('D1').value = 'TrueFalse';
  tf.forEach((v, i) => (lists.getCell(`D${i + 2}`).value = v));
  lists.columns.forEach(c => (c.width = 22));

  const headers = [
    'TaskId', // REQUIRED for update
    'Title',
    'Category',
    'Type',
    'Priority',
    'DueDate (DD-MM-YYYY)',
    'TriggerDays',
    'AssignedToEmail',
    'Status',
    'StatusNote',
    'DelayReason',
    'DelayNotes',
    'SnoozedUntil (DD-MM-YYYY)',
    'SendStartMail (true/false)',
    'ClientTo (emails ; , : separated)',
    'ClientCC (emails ; , : separated)',
    'ClientBCC (emails ; , : separated)',
    'CcAssigneeOnClientStart (true/false)',
    'CcManagerOnClientStart (true/false)',
    'ClientStartSubject',
    'ClientStartBody',
    'SendClientCompletionMail (true/false)',
    'CompletionTo (emails ; , : separated)',
    'CompletionCC (emails ; , : separated)',
    'CompletionBCC (emails ; , : separated)',
    'CcAssigneeOnCompletion (true/false)',
    'CcManagerOnCompletion (true/false)',
    'ClientCompletionSubject',
    'ClientCompletionBody',
  ];

  ws.addRow(headers);
  ws.getRow(1).font = { bold: true };
  ws.views = [{ state: 'frozen', ySplit: 1 }];

  const widths = [
    26, 36, 18, 20, 12, 20, 12, 26, 18, 36, 16, 32, 22,
    18, 28, 28, 28, 22, 22, 30, 44,
    26, 28, 28, 28, 26, 26, 30, 44
  ];
  ws.columns = headers.map((h, i) => ({ header: h, width: widths[i] || 22 }));

  // Add a sample row (TaskId empty intentionally)
  ws.addRow([
    '', 'Example: GSTR-3B Filing', 'GST', 'FILING', 'MEDIUM',
    '20-02-2026', '15', 'worker@firm.com',
    'PENDING', '', '', '', '',
    'true', '', '', '',
    'false', 'false',
    'We started {{taskTitle}}', 'Dear {{clientName}},\\n\\nWe started work on {{taskTitle}}.',
    'true', '', '', '',
    'false', 'false',
    'Completed: {{taskTitle}}', 'Dear {{clientName}},\\n\\nCompleted: {{taskTitle}} at {{completedAt}}.'
  ]);

  // Data validations
  const maxRows = 400;
  const statusRange = `Lists!$A$2:$A$${statuses.length + 1}`;
  const catRange = `Lists!$B$2:$B$${categories.length + 1}`;
  const priRange = `Lists!$C$2:$C$${priorities.length + 1}`;
  const tfRange = `Lists!$D$2:$D$${tf.length + 1}`;

  const COL_CATEGORY = headers.indexOf('Category') + 1;
  const COL_PRIORITY = headers.indexOf('Priority') + 1;
  const COL_STATUS = headers.indexOf('Status') + 1;
  const COL_SENDSTART = headers.indexOf('SendStartMail (true/false)') + 1;
  const COL_SENDCOMP = headers.indexOf('SendClientCompletionMail (true/false)') + 1;
  const COL_CC_ASSIGNEE = headers.indexOf('CcAssigneeOnClientStart (true/false)') + 1;
  const COL_CC_MANAGER = headers.indexOf('CcManagerOnClientStart (true/false)') + 1;
  const COL_CC_ASSIGNEE_COMP = headers.indexOf('CcAssigneeOnCompletion (true/false)') + 1;
  const COL_CC_MANAGER_COMP = headers.indexOf('CcManagerOnCompletion (true/false)') + 1;

  for (let r = 2; r <= maxRows; r++) {
    ws.getCell(`${col(COL_STATUS)}${r}`).dataValidation = { type:'list', allowBlank:true, formulae:[statusRange], showErrorMessage:false };
    ws.getCell(`${col(COL_CATEGORY)}${r}`).dataValidation = { type:'list', allowBlank:true, formulae:[catRange], showErrorMessage:false };
    ws.getCell(`${col(COL_PRIORITY)}${r}`).dataValidation = { type:'list', allowBlank:true, formulae:[priRange], showErrorMessage:false };

    ws.getCell(`${col(COL_SENDSTART)}${r}`).dataValidation = { type:'list', allowBlank:true, formulae:[tfRange], showErrorMessage:false };
    ws.getCell(`${col(COL_SENDCOMP)}${r}`).dataValidation = { type:'list', allowBlank:true, formulae:[tfRange], showErrorMessage:false };

    ws.getCell(`${col(COL_CC_ASSIGNEE)}${r}`).dataValidation = { type:'list', allowBlank:true, formulae:[tfRange], showErrorMessage:false };
    ws.getCell(`${col(COL_CC_MANAGER)}${r}`).dataValidation = { type:'list', allowBlank:true, formulae:[tfRange], showErrorMessage:false };
    ws.getCell(`${col(COL_CC_ASSIGNEE_COMP)}${r}`).dataValidation = { type:'list', allowBlank:true, formulae:[tfRange], showErrorMessage:false };
    ws.getCell(`${col(COL_CC_MANAGER_COMP)}${r}`).dataValidation = { type:'list', allowBlank:true, formulae:[tfRange], showErrorMessage:false };
  }

  const buf = await wb.xlsx.writeBuffer();
  return json(event, 200, {
    ok: true,
    fileName: 'Tasks_Update_Template.xlsx',
    base64: Buffer.from(buf).toString('base64')
  });
});

       --- File Content End ---


    =� jobs_client0815.js

       --- File Content Start ---

// netlify/functions/jobs_client0815.js
const {
  withCors, json, db, admin,
  ymdIST, ymdToDmy,
  getCalendarWindow,
  auditLog, renderTemplate,
  sendEmail,
  resolveStartRecipients,
  buildGoogleCalendarTemplateUrl
} = require('./_common');
const { requireCron } = require('./_auth');

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const cron = requireCron(event);
  if (cron.error) return cron.error;

  const body = event.body ? JSON.parse(event.body) : {};
  const force = !!body.force;

  const todayYmd = ymdIST(new Date());
  const settingsRef = db().collection('settings').doc('notifications');
  const settingsSnap = await settingsRef.get();
  const settings = settingsSnap.exists ? settingsSnap.data() : {};
  const last = settings.lastClient0815RunYmd || null;

  if (!force && last === todayYmd) {
    return json(event, 200, { ok:true, skipped:true, reason:'Already ran today', todayYmd });
  }

  const activeStatuses = ['PENDING','IN_PROGRESS','CLIENT_PENDING','APPROVAL_PENDING'];

  const snap = await db().collection('tasks')
    .where('startDateYmd', '==', todayYmd)
    .where('clientStartMailSent', '==', false)
    .get();

  const window = await getCalendarWindow();

  let sentCount = 0;
  let skippedNoTemplate = 0;
  let skippedNoEmail = 0;
  let skippedNoTaskClient = 0;

  for (const doc of snap.docs) {
    const t = doc.data();
    if (!activeStatuses.includes(t.status)) continue;

    // Must have template
    if (!t.clientStartSubject && !t.clientStartBody) {
      skippedNoTemplate++;
      continue;
    }

    // Load client
    if (!t.clientId) {
      skippedNoTaskClient++;
      continue;
    }
    const cSnap = await db().collection('clients').doc(t.clientId).get();
    const client = cSnap.exists ? cSnap.data() : {};

    // Resolve recipients with sendClientStartMail + internal trail + To promotion
    const recipients = await resolveStartRecipients({ client, task: t });
    if (!recipients.to.length) {
      skippedNoEmail++;
      continue;
    }

    const addToCalendarUrl = buildGoogleCalendarTemplateUrl({
      title: `START: ${t.title || 'Task'}`,
      startYmd: t.startDateYmd,
      startHH: window.startHH,
      endHH: window.endHH,
      timeZone: window.timeZone,
      details:
        `Client: ${client.name || ''}\n` +
        `Task: ${t.title || ''}\n` +
        `Start: ${ymdToDmy(t.startDateYmd)}\n` +
        `Due: ${ymdToDmy(t.dueDateYmd)}\n`
    });

    const vars = {
      clientName: client.name || '',
      taskTitle: t.title || '',
      startDate: ymdToDmy(t.startDateYmd),
      dueDate: ymdToDmy(t.dueDateYmd),
      addToCalendarUrl
    };

    const subject = renderTemplate(
      t.clientStartSubject || `We started {{taskTitle}}`,
      vars
    );

    const baseBody = renderTemplate(
      t.clientStartBody || `Dear {{clientName}},\n\nWe started work on {{taskTitle}}.\nDue: {{dueDate}}\n\nRegards,\nCompliance Team`,
      vars
    );

    const appended =
      `${baseBody}\n\n---\n` +
      `Add to your Google Calendar:\n` +
      `${addToCalendarUrl}`;

    const mailRes = await sendEmail({
      to: recipients.to,
      cc: recipients.cc,
      bcc: recipients.bcc,
      subject,
      html: appended
    });

    await doc.ref.update({
      clientStartMailSent: true,
      clientStartMailSentAt: admin.firestore.FieldValue.serverTimestamp(),
      clientStartGmailThreadId: mailRes?.threadId || null,
      clientStartGmailId: mailRes?.gmailId || null,
      clientStartRfcMessageId: mailRes?.rfcMessageId || null,
      clientStartReferences: mailRes?.references || null,
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });

    await auditLog({
      taskId: doc.id,
      action: 'EMAIL_SENT',
      actorUid: null,
      actorEmail: null,
      details: {
        type: 'CLIENT_START',
        to: recipients.to,
        cc: recipients.cc,
        bcc: recipients.bcc,
        sendClientStartMail: (t.sendClientStartMail !== false),
        addToCalendarUrl
      }
    });

    sentCount++;
  }

  await settingsRef.set({ lastClient0815RunYmd: todayYmd }, { merge: true });

  return json(event, 200, {
    ok: true,
    todayYmd,
    sentCount,
    skippedNoTemplate,
    skippedNoEmail,
    skippedNoTaskClient
  });
});

       --- File Content End ---


    =� jobs_daily.js

       --- File Content Start ---

const { withCors, json } = require('./_common');

// Kept only to avoid confusion / older calls.
// Use jobs_daily5am for actual scheduling.
exports.handler = withCors(async (event) => {
  return json(event, 200, { ok:true, note:'Use /.netlify/functions/jobs_daily5am (this one is a no-op alias).' });
});

       --- File Content End ---


    =� jobs_daily5am.js

       --- File Content Start ---

// netlify/functions/jobs_daily5am.js
const {
  withCors, json, db,
  ymdIST, ymdToDmy,
  addDays, dateFromYmdIST,
  sendEmail
} = require('./_common');
const { requireCron } = require('./_auth');

function uniq(arr) {
  return [...new Set((arr||[]).map(x=>String(x).trim()).filter(Boolean))];
}

function groupTasksForDigest(tasks, todayYmd) {
  const sections = {
    overdue: [],
    dueToday: [],
    dueIn3: [],
    dueIn7: [],
    dueIn15: [],
    dueIn30: [],
    approvalPending: [],
  };

  const toMidnight = (ymd) => new Date(`${ymd}T00:00:00+05:30`).getTime(); // IST anchored
  const t0 = toMidnight(todayYmd);

  for (const t of tasks) {
    if (!t.dueDateYmd) continue;

    if (t.status === 'APPROVAL_PENDING') sections.approvalPending.push(t);

    const d0 = toMidnight(t.dueDateYmd);
    const diffDays = Math.floor((d0 - t0) / (24 * 3600 * 1000));

    if (t.status === 'COMPLETED') continue;

    if (diffDays < 0) sections.overdue.push({ ...t, diffDays });
    else if (diffDays === 0) sections.dueToday.push({ ...t, diffDays });
    else if (diffDays <= 3) sections.dueIn3.push({ ...t, diffDays });
    else if (diffDays <= 7) sections.dueIn7.push({ ...t, diffDays });
    else if (diffDays <= 15) sections.dueIn15.push({ ...t, diffDays });
    else if (diffDays <= 30) sections.dueIn30.push({ ...t, diffDays });
  }

  const sortByDue = (a,b)=>String(a.dueDateYmd||'').localeCompare(String(b.dueDateYmd||''));
  Object.keys(sections).forEach(k => sections[k].sort(sortByDue));
  return sections;
}

async function loadClientsMap(clientIds) {
  const ids = uniq(clientIds);
  const map = new Map();
  if (!ids.length) return map;
  const refs = ids.map(id => db().collection('clients').doc(id));
  const snaps = await db().getAll(...refs);
  snaps.forEach(s => { if (s.exists) map.set(s.id, s.data()); });
  return map;
}

function escapeHtml(s) {
  return String(s || '')
    .replaceAll('&','&amp;')
    .replaceAll('<','&lt;')
    .replaceAll('>','&gt;')
    .replaceAll('"','&quot;')
    .replaceAll("'",'&#039;');
}

function renderSection(title, items, clientsMap) {
  const li = (t) => {
    const c = clientsMap.get(t.clientId) || {};
    const clientName = c.name || '';
    const due = ymdToDmy(t.dueDateYmd);
    const start = ymdToDmy(t.startDateYmd);
    const assignee = t.assignedToEmail || '';
    const status = t.status || '';
    const note = (t.statusNote || '').trim();

    // IMPORTANT CHANGE: do NOT show TaskId in digest email
    return `<li>
      <b>${escapeHtml(t.title || '')}</b>
      <div style="color:#555;font-size:12px;margin-top:2px">
        Client: ${escapeHtml(clientName)} |
        Start: ${escapeHtml(start)} |
        Due: <b>${escapeHtml(due)}</b> |
        Status: <b>${escapeHtml(status)}</b> |
        Assignee: ${escapeHtml(assignee)}
      </div>
      ${note ? `<div style="color:#666;font-size:12px;margin-top:2px">Note: ${escapeHtml(note)}</div>` : ``}
    </li>`;
  };

  if (!items.length) return '';
  return `
    <h3 style="margin:14px 0 6px">${escapeHtml(title)} (${items.length})</h3>
    <ul style="margin:0 0 10px 18px;padding:0">${items.map(li).join('')}</ul>
  `;
}

function isDigestEmpty(sections) {
  return Object.values(sections).every(arr => !arr || arr.length === 0);
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const cron = requireCron(event);
  if (cron.error) return cron.error;

  const body = event.body ? JSON.parse(event.body) : {};
  const force = !!body.force;

  const todayYmd = ymdIST(new Date());
  const settingsRef = db().collection('settings').doc('notifications');
  const settingsSnap = await settingsRef.get();
  const settings = settingsSnap.exists ? settingsSnap.data() : {
    dailyInternalEmails: [],
    dailyWindowDays: 30,
    sendDailyToAssignees: true,
    lastDailyRunYmd: null
  };

  if (!force && settings.lastDailyRunYmd === todayYmd) {
    return json(event, 200, { ok:true, skipped:true, reason:'Already ran today', todayYmd });
  }

  const activeStatuses = ['PENDING','IN_PROGRESS','CLIENT_PENDING','APPROVAL_PENDING'];
  const windowDays = Number(settings.dailyWindowDays || 30);
  const endYmd = ymdIST(addDays(dateFromYmdIST(todayYmd), windowDays));

  const dueSoonSnap = await db().collection('tasks')
    .where('status', 'in', activeStatuses)
    .where('dueDateYmd', '>=', todayYmd)
    .where('dueDateYmd', '<=', endYmd)
    .get();

  const overdueSnap = await db().collection('tasks')
    .where('status', 'in', activeStatuses)
    .where('dueDateYmd', '<', todayYmd)
    .get();

  const tasks = [
    ...dueSoonSnap.docs.map(d => ({ id:d.id, ...d.data() })),
    ...overdueSnap.docs.map(d => ({ id:d.id, ...d.data() })),
  ];

  const clientsMap = await loadClientsMap(tasks.map(t => t.clientId));
  const sectionsFirm = groupTasksForDigest(tasks, todayYmd);

  const byAssignee = new Map();
  for (const t of tasks) {
    const email = String(t.assignedToEmail || '').trim();
    if (!email) continue;
    if (!byAssignee.has(email)) byAssignee.set(email, []);
    byAssignee.get(email).push(t);
  }

  const internalExtra = uniq(settings.dailyInternalEmails || []);
  const subject = `Daily Digest (${ymdToDmy(todayYmd)})`;

  const makeHtml = (list) => {
    const s = groupTasksForDigest(list, todayYmd);

    // IMPORTANT CHANGE: if empty -> "No Tasks To Display"
    if (isDigestEmpty(s)) {
      return `
        <div style="font-family:Arial,sans-serif;line-height:1.35">
          <h2 style="margin:0 0 6px">Daily Digest — ${escapeHtml(ymdToDmy(todayYmd))}</h2>
          <div style="margin-top:10px;color:#555;font-size:13px;font-weight:700">
            No Tasks To Display
          </div>
        </div>
      `;
    }

    return `
      <div style="font-family:Arial,sans-serif;line-height:1.35">
        <h2 style="margin:0 0 6px">Firm Task Digest — ${escapeHtml(ymdToDmy(todayYmd))}</h2>
        <div style="color:#555;font-size:12px;margin-bottom:10px">
          Window: next ${windowDays} days + overdue. Statuses: ${activeStatuses.join(', ')}
        </div>
        ${renderSection('Overdue', s.overdue, clientsMap)}
        ${renderSection('Due Today', s.dueToday, clientsMap)}
        ${renderSection('Due in 1–3 days', s.dueIn3, clientsMap)}
        ${renderSection('Due in 4–7 days', s.dueIn7, clientsMap)}
        ${renderSection('Due in 8–15 days', s.dueIn15, clientsMap)}
        ${renderSection('Due in 16–30 days', s.dueIn30, clientsMap)}
        ${renderSection('Waiting for approval', s.approvalPending, clientsMap)}
        <hr style="border:none;border-top:1px solid #ddd;margin:14px 0">
        <div style="color:#777;font-size:12px">
          Tip: Use the web app to filter by client, status and due date.
        </div>
      </div>
    `;
  };

  let sentToAssignees = 0;
  if (settings.sendDailyToAssignees !== false) {
    for (const [email, list] of byAssignee.entries()) {
      await sendEmail({ to: [email], subject, html: makeHtml(list) });
      sentToAssignees++;
    }
  }

  let sentToInternal = 0;
  if (internalExtra.length) {
    await sendEmail({
      to: internalExtra,
      subject: `Firm ${subject}`,
      html: makeHtml(tasks)
    });
    sentToInternal = internalExtra.length;
  }

  await settingsRef.set({ lastDailyRunYmd: todayYmd }, { merge: true });

  return json(event, 200, {
    ok:true,
    todayYmd,
    tasksCount: tasks.length,
    sentToAssignees,
    sentToInternal
  });
});

       --- File Content End ---


    =� jobs_monthlysummary.js

       --- File Content Start ---

const { withCors, json, db, sendEmail } = require('./_common');
const { requireCron } = require('./_auth');

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const cron = requireCron(event);
  if (cron.error) return cron.error;

  // Keeping this as-is, but it will run ONLY if you schedule it.
  // If you don't want monthly mails, simply don't create a cron workflow for this.
  return json(event, 200, { ok:true, note:'Monthly summary not enabled in this setup (no-op).' });
});

       --- File Content End ---


    =� manifest.json (Skipped: Extension not selected)


    =� ping.js

       --- File Content Start ---

exports.handler = async () => {
  return {
    statusCode: 200,
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ ok: true, msg: "ping works" })
  };
};


       --- File Content End ---


    =� reports_clientHistoryPdf.js

       --- File Content Start ---

// netlify/functions/reports_clientHistoryPdf.js
const PDFDocument = require('pdfkit');
const { withCors, json, db, ymdToDmy, IST_TZ } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');

function tsToIstString(ts) {
  if (!ts || !ts.toDate) return '';
  return ts.toDate().toLocaleString('en-IN', { timeZone: IST_TZ });
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;

  const { user } = authRes;
  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const body = JSON.parse(event.body || '{}');
  const clientId = String(body.clientId || '').trim();
  const fromYmd = String(body.fromYmd || '').trim();
  const toYmd = String(body.toYmd || '').trim();

  if (!clientId || !fromYmd || !toYmd) {
    return json(event, 400, { ok:false, error:'clientId, fromYmd, toYmd required' });
  }
  if (!/^\d{4}-\d{2}-\d{2}$/.test(fromYmd) || !/^\d{4}-\d{2}-\d{2}$/.test(toYmd)) {
    return json(event, 400, { ok:false, error:'fromYmd/toYmd must be YYYY-MM-DD' });
  }

  const cSnap = await db().collection('clients').doc(clientId).get();
  if (!cSnap.exists) return json(event, 404, { ok:false, error:'Client not found' });
  const client = cSnap.data() || {};

  const tSnap = await db().collection('tasks')
    .where('clientId', '==', clientId)
    .where('dueDateYmd', '>=', fromYmd)
    .where('dueDateYmd', '<=', toYmd)
    .limit(1200)
    .get();

  const tasks = tSnap.docs.map(d => ({ id: d.id, ...d.data() }))
    .sort((a,b)=>String(a.dueDateYmd||'').localeCompare(String(b.dueDateYmd||'')));

  // Build PDF
  const doc = new PDFDocument({ size: 'A4', margin: 40 });
  const chunks = [];
  doc.on('data', (c) => chunks.push(c));
  const done = new Promise((resolve) => doc.on('end', resolve));

  doc.fontSize(16).text('Client History Report', { align: 'left' });
  doc.moveDown(0.2);
  doc.fontSize(11).text(client.name || clientId);
  doc.fontSize(9).fillColor('#444')
    .text(`Range: ${ymdToDmy(fromYmd)} to ${ymdToDmy(toYmd)}   Generated: ${new Date().toLocaleString('en-IN', { timeZone: IST_TZ })}`);
  doc.moveDown(0.7);
  doc.fillColor('#000');

  if (!tasks.length) {
    doc.fontSize(12).text('No Tasks To Display');
    doc.end();
    await done;

    return json(event, 200, {
      ok: true,
      fileName: `client_history_${(client.name || 'client').replace(/[^\w\- ]+/g, '').slice(0, 40)}_${ymdToDmy(fromYmd)}_to_${ymdToDmy(toYmd)}.pdf`,
      base64: Buffer.concat(chunks).toString('base64'),
      mime: 'application/pdf'
    });
  }

  doc.fontSize(11).text(`Tasks: ${tasks.length}`);
  doc.moveDown(0.4);

  for (const t of tasks) {
    const occ = t.seriesId ? `${t.occurrenceIndex || ''}/${t.occurrenceTotal || ''}` : '';
    const line1 = `${t.title || ''}${occ ? ` (Series ${occ})` : ''}`;
    const line2 = `Start: ${ymdToDmy(t.startDateYmd)} | Due: ${ymdToDmy(t.dueDateYmd)} | Status: ${t.status || ''} | Assignee: ${t.assignedToEmail || ''}`;
    const note = (t.statusNote || '').trim();

    doc.fontSize(11).text(line1);
    doc.fontSize(9).fillColor('#444').text(line2);
    if (note) doc.fontSize(9).fillColor('#666').text(`Note: ${note}`);
    doc.fillColor('#000');
    doc.moveDown(0.5);
    if (doc.y > 760) doc.addPage();
  }

  doc.end();
  await done;

  return json(event, 200, {
    ok: true,
    fileName: `client_history_${(client.name || 'client').replace(/[^\w\- ]+/g, '').slice(0, 40)}_${ymdToDmy(fromYmd)}_to_${ymdToDmy(toYmd)}.pdf`,
    base64: Buffer.concat(chunks).toString('base64'),
    mime: 'application/pdf'
  });
});

       --- File Content End ---


    =� reports_dailyDigestPdf.js

       --- File Content Start ---

// netlify/functions/reports_dailyDigestPdf.js
// Optional: firm daily digest as PDF (Partner-only)
const PDFDocument = require('pdfkit');
const { withCors, json, db, ymdIST, ymdToDmy, addDays, dateFromYmdIST, IST_TZ } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');

async function loadClientsMap(clientIds) {
  const ids = [...new Set((clientIds || []).filter(Boolean))];
  const map = new Map();
  if (!ids.length) return map;
  const refs = ids.map(id => db().collection('clients').doc(id));
  const snaps = await db().getAll(...refs);
  snaps.forEach(s => { if (s.exists) map.set(s.id, s.data()); });
  return map;
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;

  const { user } = authRes;
  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const body = JSON.parse(event.body || '{}');
  const todayYmd = ymdIST(new Date());

  // Use same settings doc as email digest
  const settingsSnap = await db().collection('settings').doc('notifications').get();
  const settings = settingsSnap.exists ? settingsSnap.data() : { dailyWindowDays: 30 };
  const windowDays = Number(settings.dailyWindowDays || 30);
  const endYmd = ymdIST(addDays(dateFromYmdIST(todayYmd), windowDays));

  const activeStatuses = ['PENDING','IN_PROGRESS','CLIENT_PENDING','APPROVAL_PENDING'];

  const dueSoonSnap = await db().collection('tasks')
    .where('status', 'in', activeStatuses)
    .where('dueDateYmd', '>=', todayYmd)
    .where('dueDateYmd', '<=', endYmd)
    .limit(1500)
    .get();

  const overdueSnap = await db().collection('tasks')
    .where('status', 'in', activeStatuses)
    .where('dueDateYmd', '<', todayYmd)
    .limit(1500)
    .get();

  const tasks = [
    ...dueSoonSnap.docs.map(d => ({ id:d.id, ...d.data() })),
    ...overdueSnap.docs.map(d => ({ id:d.id, ...d.data() })),
  ].sort((a,b)=>String(a.dueDateYmd||'').localeCompare(String(b.dueDateYmd||'')));

  const clientsMap = await loadClientsMap(tasks.map(t => t.clientId));

  const doc = new PDFDocument({ size:'A4', margin:40 });
  const chunks = [];
  doc.on('data', c => chunks.push(c));
  const done = new Promise(resolve => doc.on('end', resolve));

  doc.fontSize(16).text('Daily Digest (PDF)');
  doc.moveDown(0.2);
  doc.fontSize(10).fillColor('#444')
    .text(`Date: ${ymdToDmy(todayYmd)}   Window: next ${windowDays} days + overdue`)
    .text(`Generated: ${new Date().toLocaleString('en-IN',{ timeZone: IST_TZ })}`);
  doc.fillColor('#000');
  doc.moveDown(0.8);

  if (!tasks.length) {
    doc.fontSize(12).text('No Tasks To Display');
    doc.end();
    await done;
    return json(event, 200, {
      ok:true,
      fileName: `daily_digest_${ymdToDmy(todayYmd)}.pdf`,
      base64: Buffer.concat(chunks).toString('base64'),
      mime: 'application/pdf'
    });
  }

  doc.fontSize(11).text(`Tasks: ${tasks.length}`);
  doc.moveDown(0.4);

  for (const t of tasks) {
    const c = clientsMap.get(t.clientId) || {};
    doc.fontSize(11).text(`${c.name || ''} — ${t.title || ''}`);
    doc.fontSize(9).fillColor('#444')
      .text(`Due: ${ymdToDmy(t.dueDateYmd)} | Status: ${t.status || ''} | Assignee: ${t.assignedToEmail || ''}`);
    const note = (t.statusNote || '').trim();
    if (note) doc.fontSize(9).fillColor('#666').text(`Note: ${note}`);
    doc.fillColor('#000');
    doc.moveDown(0.4);
    if (doc.y > 760) doc.addPage();
  }

  doc.end();
  await done;

  return json(event, 200, {
    ok:true,
    fileName: `daily_digest_${ymdToDmy(todayYmd)}.pdf`,
    base64: Buffer.concat(chunks).toString('base64'),
    mime: 'application/pdf'
  });
});

       --- File Content End ---


    =� reports_firmRangePdf.js

       --- File Content Start ---

// netlify/functions/reports_firmRangePdf.js
const PDFDocument = require('pdfkit');
const { withCors, json, db, dmyToYmd, ymdToDmy, IST_TZ } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');

function tsToIstString(ts) {
  if (!ts || !ts.toDate) return '';
  return ts.toDate().toLocaleString('en-IN', { timeZone: IST_TZ });
}

async function loadClientsMap(clientIds) {
  const ids = [...new Set((clientIds || []).filter(Boolean))];
  const map = new Map();
  if (!ids.length) return map;
  const refs = ids.map(id => db().collection('clients').doc(id));
  const snaps = await db().getAll(...refs);
  snaps.forEach(s => { if (s.exists) map.set(s.id, s.data()); });
  return map;
}

function mustYmdFromInput({ fromDmy, toDmy, fromYmd, toYmd }) {
  const pick = (x) => (x == null ? '' : String(x).trim());
  if (pick(fromDmy) && pick(toDmy)) {
    return { fromY: dmyToYmd(fromDmy), toY: dmyToYmd(toDmy) };
  }
  if (pick(fromYmd) && pick(toYmd)) {
    return { fromY: pick(fromYmd), toY: pick(toYmd) };
  }
  throw new Error('Provide fromDmy & toDmy (DD-MM-YYYY) or fromYmd & toYmd (YYYY-MM-DD)');
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;

  const { user } = authRes;
  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const body = JSON.parse(event.body || '{}');
  let fromY, toY;
  try { ({ fromY, toY } = mustYmdFromInput(body)); }
  catch (e) { return json(event, 400, { ok:false, error: e.message }); }

  // optional filters
  const clientId = body.clientId ? String(body.clientId) : null;
  const status = body.status ? String(body.status) : null;
  const assignedToEmail = body.assignedToEmail ? String(body.assignedToEmail) : null;

  let q = db().collection('tasks')
    .where('dueDateYmd', '>=', fromY)
    .where('dueDateYmd', '<=', toY);

  if (clientId) q = q.where('clientId', '==', clientId);
  if (status) q = q.where('status', '==', status);
  if (assignedToEmail) q = q.where('assignedToEmail', '==', assignedToEmail);

  const tasksSnap = await q.limit(800).get();
  const tasks = tasksSnap.docs.map(d => ({ id: d.id, ...d.data() }))
    .sort((a,b)=>String(a.dueDateYmd||'').localeCompare(String(b.dueDateYmd||'')));

  const clientsMap = await loadClientsMap(tasks.map(t => t.clientId));

  // Build PDF
  const doc = new PDFDocument({ size: 'A4', margin: 40 });
  const chunks = [];
  doc.on('data', (c) => chunks.push(c));
  const done = new Promise((resolve) => doc.on('end', resolve));

  doc.fontSize(16).text('Firm Tasks Report', { align: 'left' });
  doc.moveDown(0.25);
  doc.fontSize(10).fillColor('#444')
    .text(`Range: ${ymdToDmy(fromY)} to ${ymdToDmy(toY)}   Generated: ${new Date().toLocaleString('en-IN', { timeZone: IST_TZ })}`);
  doc.moveDown(0.8);

  doc.fillColor('#000');

  if (!tasks.length) {
    doc.fontSize(12).text('No Tasks To Display');
    doc.end();
    await done;

    return json(event, 200, {
      ok: true,
      fileName: `firm_tasks_${ymdToDmy(fromY)}_to_${ymdToDmy(toY)}.pdf`,
      base64: Buffer.concat(chunks).toString('base64'),
      mime: 'application/pdf'
    });
  }

  // Simple list layout (PDFKit-friendly)
  doc.fontSize(11).text(`Tasks: ${tasks.length}`);
  doc.moveDown(0.4);

  for (const t of tasks) {
    const c = clientsMap.get(t.clientId) || {};
    const line1 = `${c.name || ''} — ${t.title || ''}`;
    const line2 = `Due: ${ymdToDmy(t.dueDateYmd)} | Start: ${ymdToDmy(t.startDateYmd)} | Status: ${t.status || ''} | Assignee: ${t.assignedToEmail || ''}`;
    const note = (t.statusNote || '').trim();

    doc.fontSize(11).text(line1);
    doc.fontSize(9).fillColor('#444').text(line2);
    if (note) doc.fontSize(9).fillColor('#666').text(`Note: ${note}`);
    doc.fillColor('#000');
    doc.moveDown(0.5);

    // page break safeguard
    if (doc.y > 760) doc.addPage();
  }

  doc.end();
  await done;

  return json(event, 200, {
    ok: true,
    fileName: `firm_tasks_${ymdToDmy(fromY)}_to_${ymdToDmy(toY)}.pdf`,
    base64: Buffer.concat(chunks).toString('base64'),
    mime: 'application/pdf'
  });
});

       --- File Content End ---


    =� reports_monthlyPdf.js

       --- File Content Start ---

// netlify/functions/reports_monthlyPdf.js
// Optional monthly PDF summary (firm-wide). Partner-only.
const PDFDocument = require('pdfkit');
const { withCors, json, db, ymdIST, ymdToDmy, addDays, dateFromYmdIST, IST_TZ } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');

async function loadClientsMap(clientIds) {
  const ids = [...new Set((clientIds || []).filter(Boolean))];
  const map = new Map();
  if (!ids.length) return map;
  const refs = ids.map(id => db().collection('clients').doc(id));
  const snaps = await db().getAll(...refs);
  snaps.forEach(s => { if (s.exists) map.set(s.id, s.data()); });
  return map;
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;

  const { user } = authRes;
  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const body = JSON.parse(event.body || '{}');
  // monthYmd: any date within month (YYYY-MM-DD). Default: today
  const monthYmd = String(body.monthYmd || ymdIST(new Date())).trim();
  if (!/^\d{4}-\d{2}-\d{2}$/.test(monthYmd)) return json(event, 400, { ok:false, error:'monthYmd must be YYYY-MM-DD' });

  const dt = dateFromYmdIST(monthYmd);
  const y = dt.getUTCFullYear();
  const m = dt.getUTCMonth(); // 0-based in UTC
  const monthStart = new Date(Date.UTC(y, m, 1));
  const monthEnd = new Date(Date.UTC(y, m + 1, 0)); // last day
  const fromYmd = ymdIST(monthStart);
  const toYmd = ymdIST(monthEnd);

  const activeStatuses = ['PENDING','IN_PROGRESS','CLIENT_PENDING','APPROVAL_PENDING'];

  const snap = await db().collection('tasks')
    .where('status', 'in', activeStatuses)
    .where('dueDateYmd', '>=', fromYmd)
    .where('dueDateYmd', '<=', toYmd)
    .limit(1500)
    .get();

  const tasks = snap.docs.map(d => ({ id:d.id, ...d.data() }))
    .sort((a,b)=>String(a.dueDateYmd||'').localeCompare(String(b.dueDateYmd||'')));

  const clientsMap = await loadClientsMap(tasks.map(t => t.clientId));

  const doc = new PDFDocument({ size:'A4', margin:40 });
  const chunks = [];
  doc.on('data', c => chunks.push(c));
  const done = new Promise(resolve => doc.on('end', resolve));

  doc.fontSize(16).text('Monthly Compliance Summary');
  doc.moveDown(0.2);
  doc.fontSize(10).fillColor('#444')
    .text(`Month: ${fromYmd.slice(0,7)}   Range: ${ymdToDmy(fromYmd)} to ${ymdToDmy(toYmd)}`)
    .text(`Generated: ${new Date().toLocaleString('en-IN',{ timeZone: IST_TZ })}`);
  doc.fillColor('#000');
  doc.moveDown(0.8);

  if (!tasks.length) {
    doc.fontSize(12).text('No Tasks To Display');
    doc.end();
    await done;
    return json(event, 200, {
      ok:true,
      fileName: `monthly_summary_${fromYmd.slice(0,7)}.pdf`,
      base64: Buffer.concat(chunks).toString('base64'),
      mime: 'application/pdf'
    });
  }

  doc.fontSize(11).text(`Open items due this month: ${tasks.length}`);
  doc.moveDown(0.5);

  for (const t of tasks) {
    const c = clientsMap.get(t.clientId) || {};
    doc.fontSize(11).text(`${c.name || ''} — ${t.title || ''}`);
    doc.fontSize(9).fillColor('#444')
      .text(`Due: ${ymdToDmy(t.dueDateYmd)} | Status: ${t.status || ''} | Assignee: ${t.assignedToEmail || ''}`);
    doc.fillColor('#000');
    doc.moveDown(0.4);
    if (doc.y > 760) doc.addPage();
  }

  doc.end();
  await done;

  return json(event, 200, {
    ok:true,
    fileName: `monthly_summary_${fromYmd.slice(0,7)}.pdf`,
    base64: Buffer.concat(chunks).toString('base64'),
    mime: 'application/pdf'
  });
});

       --- File Content End ---


    =� reports_taskHistoryPdf.js

       --- File Content Start ---

// netlify/functions/reports_taskHistoryPdf.js
const PDFDocument = require('pdfkit');
const { withCors, json, db, ymdToDmy, IST_TZ } = require('./_common');
const { requireUser } = require('./_auth');

function roleOf(user) {
  let r = String(user?.role || 'ASSOCIATE').toUpperCase().trim();
  if (r === 'WORKER') r = 'ASSOCIATE';
  return r || 'ASSOCIATE';
}
function isPrivileged(role) {
  return role === 'PARTNER' || role === 'MANAGER';
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;

  const { user } = authRes;
  const role = roleOf(user);
  const privileged = isPrivileged(role);

  const body = JSON.parse(event.body || '{}');
  const taskId = String(body.taskId || '').trim();
  if (!taskId) return json(event, 400, { ok:false, error:'taskId required' });

  const tSnap = await db().collection('tasks').doc(taskId).get();
  if (!tSnap.exists) return json(event, 404, { ok:false, error:'Task not found' });
  const task = tSnap.data();

  if (!privileged && task.assignedToUid !== user.uid) {
    return json(event, 403, { ok:false, error:'Not allowed' });
  }

  const cSnap = task.clientId ? await db().collection('clients').doc(task.clientId).get() : null;
  const client = cSnap && cSnap.exists ? (cSnap.data() || {}) : {};

  const aSnap = await db().collection('auditLogs').where('taskId', '==', taskId).get();
  const logs = aSnap.docs.map(d => d.data())
    .sort((x,y)=> (x.timestamp?.toMillis?.()||0) - (y.timestamp?.toMillis?.()||0));

  const comSnap = await db().collection('tasks').doc(taskId).collection('comments')
    .orderBy('createdAt', 'asc')
    .limit(400)
    .get();
  const comments = comSnap.docs.map(d => d.data());

  const attachments = Array.isArray(task.attachments) ? task.attachments : [];

  // PDF
  const doc = new PDFDocument({ size: 'A4', margin: 40 });
  const chunks = [];
  doc.on('data', (c) => chunks.push(c));
  const done = new Promise((resolve) => doc.on('end', resolve));

  doc.fontSize(16).text('Task History Report');
  doc.moveDown(0.2);

  doc.fontSize(11).text(task.title || 'Task');
  doc.fontSize(9).fillColor('#444')
    .text(`Client: ${client.name || ''}`)
    .text(`Start: ${ymdToDmy(task.startDateYmd)}   Due: ${ymdToDmy(task.dueDateYmd)}   Status: ${task.status || ''}`)
    .text(`Assignee: ${task.assignedToEmail || ''}`)
    .text(`Generated: ${new Date().toLocaleString('en-IN', { timeZone: IST_TZ })}`);
  doc.fillColor('#000');
  doc.moveDown(0.8);

  doc.fontSize(12).text('Timeline', { underline: true });
  doc.moveDown(0.2);
  if (!logs.length) {
    doc.fontSize(10).fillColor('#666').text('No timeline entries.');
    doc.fillColor('#000');
  } else {
    for (const a of logs) {
      const when = a.timestamp?.toDate?.()
        ? a.timestamp.toDate().toLocaleString('en-IN', { timeZone: IST_TZ })
        : '';
      doc.fontSize(10).text(`${when} — ${a.action || ''}`);
      if (a.actorEmail) doc.fontSize(9).fillColor('#444').text(a.actorEmail);
      doc.fillColor('#666').fontSize(9).text(JSON.stringify(a.details || {}));
      doc.fillColor('#000');
      doc.moveDown(0.4);
      if (doc.y > 760) doc.addPage();
    }
  }

  doc.moveDown(0.6);
  doc.fontSize(12).text('Comments', { underline: true });
  doc.moveDown(0.2);
  if (!comments.length) {
    doc.fontSize(10).fillColor('#666').text('No comments.');
    doc.fillColor('#000');
  } else {
    for (const c of comments) {
      const when = c.createdAt?.toDate?.()
        ? c.createdAt.toDate().toLocaleString('en-IN', { timeZone: IST_TZ })
        : '';
      const who = c.authorName || c.authorEmail || '';
      doc.fontSize(10).text(`${when} — ${who}`);
      doc.fontSize(9).fillColor('#444').text(String(c.text || ''), { width: 520 });
      doc.fillColor('#000');
      doc.moveDown(0.4);
      if (doc.y > 760) doc.addPage();
    }
  }

  doc.moveDown(0.6);
  doc.fontSize(12).text('Attachments', { underline: true });
  doc.moveDown(0.2);
  if (!attachments.length) {
    doc.fontSize(10).fillColor('#666').text('No attachments.');
    doc.fillColor('#000');
  } else {
    for (const a of attachments) {
      doc.fontSize(10).text(`${a.type || ''} — ${a.fileName || ''}`);
      if (a.driveWebViewLink) doc.fontSize(9).fillColor('#1a73e8').text(a.driveWebViewLink);
      doc.fillColor('#000');
      doc.moveDown(0.3);
      if (doc.y > 760) doc.addPage();
    }
  }

  doc.end();
  await done;

  const safeTitle = String(task.title || 'task').replace(/[^\w\- ]+/g, '').slice(0, 40).trim() || 'task';
  return json(event, 200, {
    ok: true,
    fileName: `task_history_${safeTitle}_${taskId}.pdf`,
    base64: Buffer.concat(chunks).toString('base64'),
    mime: 'application/pdf'
  });
});

       --- File Content End ---


    =� roles_migrate_worker_to_associate.js

       --- File Content Start ---

// netlify/functions/roles_migrate_worker_to_associate.js
const { withCors, json, db, admin } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');

/**
 * One-time migration: users.role WORKER -> ASSOCIATE
 * Partner-only.
 *
 * Body:
 * { dryRun?: boolean, limit?: number }
 */
exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;

  const { user } = authRes;
  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const body = JSON.parse(event.body || '{}');
  const dryRun = body.dryRun !== false; // default true
  const limit = Math.min(2000, Math.max(1, Number(body.limit || 800)));

  // Find users with role == WORKER
  const snap = await db().collection('users').where('role', '==', 'WORKER').limit(limit).get();
  if (snap.empty) {
    return json(event, 200, { ok:true, dryRun, updated: 0, note: 'No WORKER roles found' });
  }

  const users = snap.docs.map(d => ({ uid: d.id, ...d.data() }));
  if (dryRun) {
    return json(event, 200, {
      ok: true,
      dryRun: true,
      found: users.length,
      sample: users.slice(0, 20).map(u => ({ uid: u.uid, email: u.email }))
    });
  }

  // Batch updates (max 500 per batch)
  let updated = 0;
  let batch = db().batch();
  let ops = 0;

  for (const u of users) {
    const ref = db().collection('users').doc(u.uid);
    batch.set(ref, {
      role: 'ASSOCIATE',
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedBy: user.email
    }, { merge: true });
    ops++;
    updated++;

    if (ops >= 450) {
      await batch.commit();
      batch = db().batch();
      ops = 0;
    }
  }
  if (ops) await batch.commit();

  return json(event, 200, { ok:true, dryRun: false, updated });
});

       --- File Content End ---


    =� series_reassign.js

       --- File Content Start ---

// netlify/functions/series_reassign.js
const { withCors, json, db, admin, auditLog } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');

async function findUserUidByEmail(email) {
  if (!email) return null;
  const e = String(email).trim().toLowerCase();

  let snap = await db().collection('users').where('emailLower', '==', e).limit(1).get();
  if (snap.empty) snap = await db().collection('users').where('email', '==', email).limit(1).get();
  if (snap.empty) return null;

  return snap.docs[0].id;
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const body = JSON.parse(event.body || '{}');
  const { seriesId, assignedToEmail } = body;

  if (!seriesId || !assignedToEmail) {
    return json(event, 400, { ok:false, error:'seriesId and assignedToEmail required' });
  }

  const uid = await findUserUidByEmail(assignedToEmail);
  if (!uid) {
    return json(event, 400, { ok:false, error:'assignedToEmail not found in users collection' });
  }

  const snap = await db().collection('tasks').where('seriesId', '==', seriesId).get();
  if (snap.empty) return json(event, 404, { ok:false, error:'No tasks found for seriesId' });

  const batch = db().batch();
  snap.docs.forEach(d => batch.update(d.ref, {
    assignedToEmail,
    assignedToUid: uid,
    updatedAt: admin.firestore.FieldValue.serverTimestamp()
  }));
  await batch.commit();

  await auditLog({
    taskId: null,
    action: 'SERIES_REASSIGN',
    actorUid: user.uid,
    actorEmail: user.email,
    details: { seriesId, assignedToEmail }
  });

  return json(event, 200, { ok:true, updatedCount: snap.size });
});

       --- File Content End ---


    =� series_rebuild.js

       --- File Content Start ---

// netlify/functions/series_rebuild.js
const {
  withCors, json, db, admin,
  calendar, ymdIST, addDays, addInterval, dateFromYmdIST,
  getCalendarWindow, calTimeRange,
  auditLog
} = require('./_common');
const { requireUser, requirePartner } = require('./_auth');

async function findUserUidByEmail(email) {
  if (!email) return null;
  const e = String(email).trim().toLowerCase();

  let snap = await db().collection('users').where('emailLower', '==', e).limit(1).get();
  if (snap.empty) snap = await db().collection('users').where('email', '==', email).limit(1).get();
  if (snap.empty) return null;

  return snap.docs[0].id;
}

async function createStartCalendarEvent({ title, clientId, startDateYmd, dueDateYmd, window }) {
  const cal = calendar();
  const range = calTimeRange(startDateYmd, window.startHH, window.endHH, window.timeZone);
  const res = await cal.events.insert({
    calendarId: 'primary',
    sendUpdates: 'none',
    requestBody: {
      summary: `START: ${title}`,
      description: `ClientId: ${clientId}\nStart: ${startDateYmd}\nDue: ${dueDateYmd}`,
      ...range
    }
  });
  return { calendarEventId: res.data.id, calendarHtmlLink: res.data.htmlLink || null };
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const body = JSON.parse(event.body || '{}');
  const { seriesId, addCount } = body;

  if (!seriesId) return json(event, 400, { ok:false, error:'seriesId required' });

  const n = Math.max(1, parseInt(addCount || '1', 10));

  // Load existing tasks in series
  const snap = await db().collection('tasks').where('seriesId', '==', seriesId).get();
  if (snap.empty) return json(event, 404, { ok:false, error:'No tasks found for seriesId' });

  const tasks = snap.docs.map(d => ({ id: d.id, ref: d.ref, data: d.data() }));
  const first = tasks[0].data;

  // Base due date = occurrenceIndex==1 dueDateYmd if exists; else min dueDateYmd
  let baseDueYmd = null;
  const occ1 = tasks.find(x => x.data.occurrenceIndex === 1);
  if (occ1) baseDueYmd = occ1.data.dueDateYmd;
  if (!baseDueYmd) baseDueYmd = tasks.map(x => x.data.dueDateYmd).sort()[0];

  const baseDueDate = dateFromYmdIST(baseDueYmd);

  // Determine existing max idx
  let maxIdx = 0;
  const idxSet = new Set();
  for (const t of tasks) {
    const idx = Number(t.data.occurrenceIndex || 0);
    if (idx > maxIdx) maxIdx = idx;
    if (idx) idxSet.add(idx);
  }

  const recurrence = first.recurrence || 'MONTHLY';
  const triggerDaysBefore = Number(first.triggerDaysBefore || 15);

  const assignedToEmail = body.assignedToEmail || first.assignedToEmail || user.email;
  const assignedToUid = (await findUserUidByEmail(assignedToEmail)) || first.assignedToUid || user.uid;

  const window = await getCalendarWindow();

  let created = 0;
  const startIdx = maxIdx + 1;
  const endIdx = maxIdx + n;

  for (let idx = startIdx; idx <= endIdx; idx++) {
    if (idxSet.has(idx)) continue;

    const dueDate = addInterval(baseDueDate, recurrence, idx - 1);
    const dueDateYmd = ymdIST(dueDate);
    const startDateYmd = ymdIST(addDays(dateFromYmdIST(dueDateYmd), -triggerDaysBefore));

    const ev = await createStartCalendarEvent({
      title: first.title,
      clientId: first.clientId,
      startDateYmd,
      dueDateYmd,
      window
    });

    const tRef = db().collection('tasks').doc();
    await tRef.set({
      ...first,
      occurrenceIndex: idx,
      occurrenceTotal: (first.occurrenceTotal || maxIdx) + n,

      dueDate: admin.firestore.Timestamp.fromDate(dateFromYmdIST(dueDateYmd)),
      dueDateYmd,

      startDate: admin.firestore.Timestamp.fromDate(dateFromYmdIST(startDateYmd)),
      startDateYmd,

      assignedToEmail,
      assignedToUid,

      calendarEventId: ev.calendarEventId,
      calendarHtmlLink: ev.calendarHtmlLink || null,
      calendarStartEventId: ev.calendarEventId,
      calendarDueEventId: null,

      clientStartMailSent: false,
      clientStartMailSentAt: null,
      clientStartGmailThreadId: null,
      clientStartGmailId: null,
      clientStartRfcMessageId: null,
      clientStartReferences: null,

      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });

    await auditLog({
      taskId: tRef.id,
      action: 'SERIES_REBUILD_CREATED',
      actorUid: user.uid,
      actorEmail: user.email,
      details: { seriesId, occurrenceIndex: idx, startDateYmd, dueDateYmd }
    });

    created++;
  }

  // Update occurrenceTotal on all existing tasks to match new endIdx
  const newTotal = endIdx;
  const batch = db().batch();
  tasks.forEach(t => batch.update(t.ref, { occurrenceTotal: newTotal }));
  await batch.commit();

  return json(event, 200, { ok:true, created, newTotal });
});

       --- File Content End ---


    =� settings_calendar_get.js

       --- File Content Start ---

const { withCors, json, db } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const snap = await db().collection('settings').doc('calendar').get();
  const data = snap.exists ? snap.data() : null;

  return json(event, 200, {
    ok:true,
    data: data || { startHH: 10, endHH: 12, timeZone: 'Asia/Kolkata' }
  });
});

       --- File Content End ---


    =� settings_calendar_update.js

       --- File Content Start ---

const { withCors, json, db, admin } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');

function clampHH(x, def) {
  const n = Number(x);
  if (!Number.isFinite(n)) return def;
  return Math.min(23, Math.max(0, Math.floor(n)));
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const body = JSON.parse(event.body || '{}');

  const startHH = clampHH(body.startHH, 10);
  const endHH = clampHH(body.endHH, 12);
  if (endHH <= startHH) {
    return json(event, 400, { ok:false, error:'endHH must be > startHH' });
  }

  const timeZone = String(body.timeZone || 'Asia/Kolkata').trim() || 'Asia/Kolkata';

  await db().collection('settings').doc('calendar').set({
    startHH,
    endHH,
    timeZone,
    updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    updatedBy: user.email
  }, { merge: true });

  return json(event, 200, { ok:true });
});

       --- File Content End ---


    =� settings_get.js

       --- File Content Start ---

const { withCors, json, db } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const snap = await db().collection('settings').doc('notifications').get();
  const data = snap.exists ? snap.data() : null;

  return json(event, 200, {
    ok:true,
    data: data || {
      dailyInternalEmails: [],
      dailyWindowDays: 30,
      sendDailyToAssignees: true,
      lastDailyRunYmd: null
    }
  });
});

       --- File Content End ---


    =� settings_update.js

       --- File Content Start ---

const { withCors, json, db, admin } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');

function asEmailList(x) {
  if (Array.isArray(x)) return x.map(s => String(s).trim()).filter(Boolean);
  if (typeof x === 'string') return x.split(/[;,]/).map(s => s.trim()).filter(Boolean);
  return [];
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const body = JSON.parse(event.body || '{}');

  const doc = {
    dailyInternalEmails: asEmailList(body.dailyInternalEmails),
    dailyWindowDays: Number(body.dailyWindowDays || 30),
    sendDailyToAssignees: body.sendDailyToAssignees !== false,
    updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    updatedBy: user.email
  };

  await db().collection('settings').doc('notifications').set(doc, { merge: true });
  return json(event, 200, { ok:true });
});

       --- File Content End ---


    =� settings_workerimportpassword_set.js

       --- File Content Start ---

// netlify/functions/settings_workerImportPassword_set.js
const crypto = require('crypto');
const { withCors, json, db, admin } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');

/**
 * We store a PBKDF2 hash so we never store plaintext password.
 * Doc: settings/security
 * Fields:
 *  - workerImportEnabled: boolean
 *  - workerImportHash: string (base64)
 *  - workerImportSalt: string (base64)
 *  - workerImportIter: number
 *  - updatedAt, updatedBy
 */

function pbkdf2Hash(password, saltBuf, iter = 120000) {
  const keyLen = 32;
  const digest = 'sha256';
  const derived = crypto.pbkdf2Sync(password, saltBuf, iter, keyLen, digest);
  return derived;
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const body = JSON.parse(event.body || '{}');
  const password = String(body.password || '');

  const ref = db().collection('settings').doc('security');

  // Remove/disable password
  if (!password) {
    await ref.set({
      workerImportEnabled: false,
      workerImportHash: null,
      workerImportSalt: null,
      workerImportIter: null,
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedBy: user.email
    }, { merge: true });

    return json(event, 200, { ok:true, enabled:false });
  }

  if (password.length < 4) {
    return json(event, 400, { ok:false, error:'Password too short (min 4 characters)' });
  }

  const salt = crypto.randomBytes(16);
  const iter = 120000;
  const hash = pbkdf2Hash(password, salt, iter);

  await ref.set({
    workerImportEnabled: true,
    workerImportHash: hash.toString('base64'),
    workerImportSalt: salt.toString('base64'),
    workerImportIter: iter,
    updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    updatedBy: user.email
  }, { merge: true });

  return json(event, 200, { ok:true, enabled:true });
});

       --- File Content End ---


    =� tasks_addcomment.js

       --- File Content Start ---

// netlify/functions/tasks_addcomment.js
const { withCors, json, db, admin, auditLog } = require('./_common');
const { requireUser } = require('./_auth');

/**
 * Adds a comment to tasks/{taskId}/comments and creates notification docs for @mentions.
 *
 * Request body:
 * { taskId: string, text: string }
 *
 * Mention formats supported:
 * - @email@example.com
 * - @Full Name  (matches users.displayName case-insensitive; spaces allowed until punctuation/end)
 *
 * Notifications collection:
 * notifications/{autoId} with:
 * - toUid
 * - type: 'MENTION'
 * - createdAt
 * - readAt: null
 * - payload: { taskId, taskTitle, byEmail, byName, snippet }
 *
 * Permissions:
 * - PARTNER/MANAGER can comment on any task
 * - ASSOCIATE can comment only on tasks assigned to them
 */

function roleOf(user) {
  let r = String(user?.role || 'ASSOCIATE').toUpperCase().trim() || 'ASSOCIATE';
  if (r === 'WORKER') r = 'ASSOCIATE'; // backward compatibility
  return r;
}
function isPrivileged(role) {
  return role === 'PARTNER' || role === 'MANAGER';
}

function cleanText(x) {
  return String(x || '').replace(/\r\n/g, '\n').trim();
}

function extractMentions(text) {
  const t = String(text || '');

  // 1) emails like @a@b.com
  const emailMentions = [];
  const emailRe = /@([^\s@]+@[^\s@]+\.[^\s@]+)/g;
  let m;
  while ((m = emailRe.exec(t)) !== null) {
    emailMentions.push(m[1]);
  }

  // 2) name mentions like @John Doe (stop at newline or ".,;:!?)(")
  const nameMentions = [];
  const nameRe = /@([A-Za-z][A-Za-z0-9 _-]{1,40})(?=$|[\n\r\t.,;:!?()[\]{}])/g;
  while ((m = nameRe.exec(t)) !== null) {
    const name = String(m[1] || '').trim();
    if (name.includes('@')) continue;
    nameMentions.push(name);
  }

  return {
    emails: [...new Set(emailMentions.map(e => e.trim()).filter(Boolean))],
    names: [...new Set(nameMentions.map(n => n.trim()).filter(Boolean))]
  };
}

async function findUsersByEmails(emails) {
  const out = [];
  const uniq = [...new Set((emails || []).map(e => String(e).trim().toLowerCase()).filter(Boolean))];
  if (!uniq.length) return out;

  // Firestore doesn't support "in" with more than 10 values reliably; chunk
  const chunks = [];
  for (let i = 0; i < uniq.length; i += 10) chunks.push(uniq.slice(i, i + 10));

  for (const c of chunks) {
    const snap = await db().collection('users').where('emailLower', 'in', c).get();
    snap.docs.forEach(d => out.push({ uid: d.id, ...d.data() }));
  }
  return out;
}

async function findUsersByDisplayNames(names) {
  const uniq = [...new Set((names || []).map(n => String(n).trim().toLowerCase()).filter(Boolean))];
  if (!uniq.length) return [];

  // Fast path using displayNameLower
  let out = [];
  try {
    const chunks = [];
    for (let i = 0; i < uniq.length; i += 10) chunks.push(uniq.slice(i, i + 10));
    for (const c of chunks) {
      const snap = await db().collection('users').where('displayNameLower', 'in', c).get();
      snap.docs.forEach(d => out.push({ uid: d.id, ...d.data() }));
    }
    if (out.length) return out;
  } catch {
    // ignore and fallback scan
  }

  // Fallback: scan up to 500 users and match in memory
  const snap = await db().collection('users').orderBy('email', 'asc').limit(500).get();
  const all = snap.docs.map(d => ({ uid: d.id, ...d.data() }));
  out = all.filter(u => {
    const dn = String(u.displayName || '').trim().toLowerCase();
    return dn && uniq.includes(dn);
  });
  return out;
}

async function createNotifications({ toUids, payload }) {
  const uniq = [...new Set((toUids || []).map(x => String(x || '').trim()).filter(Boolean))];
  if (!uniq.length) return 0;

  const ref = db().collection('notifications');
  let created = 0;

  const batches = [];
  for (let i = 0; i < uniq.length; i += 400) batches.push(uniq.slice(i, i + 400));

  for (const group of batches) {
    const b = db().batch();
    for (const uid of group) {
      const docRef = ref.doc();
      b.set(docRef, {
        toUid: uid,
        type: 'MENTION',
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        readAt: null,
        payload: payload || {}
      });
      created++;
    }
    await b.commit();
  }

  return created;
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok: false, error: 'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const role = roleOf(user);

  const body = JSON.parse(event.body || '{}');
  const taskId = String(body.taskId || '').trim();
  const text = cleanText(body.text);

  if (!taskId) return json(event, 400, { ok: false, error: 'taskId required' });
  if (!text) return json(event, 400, { ok: false, error: 'text required' });
  if (text.length > 5000) return json(event, 400, { ok: false, error: 'text too long (max 5000)' });

  const tRef = db().collection('tasks').doc(taskId);
  const tSnap = await tRef.get();
  if (!tSnap.exists) return json(event, 404, { ok: false, error: 'Task not found' });
  const task = tSnap.data();

  if (!isPrivileged(role)) {
    const isAssignee = task.assignedToUid === user.uid;
    if (!isAssignee) return json(event, 403, { ok: false, error: 'Not allowed' });
  }

  // Load author display name if available
  let authorName = '';
  try {
    const uSnap = await db().collection('users').doc(user.uid).get();
    if (uSnap.exists) {
      const u = uSnap.data() || {};
      authorName = u.displayName || '';
    }
  } catch {}

  // Create comment doc
  const cRef = tRef.collection('comments').doc();
  await cRef.set({
    text,
    authorUid: user.uid,
    authorEmail: user.email || '',
    authorName: authorName || '',
    createdAt: admin.firestore.FieldValue.serverTimestamp()
  });

  await auditLog({
    taskId,
    action: 'COMMENT_ADDED',
    actorUid: user.uid,
    actorEmail: user.email,
    details: { length: text.length }
  });

  // Mentions -> notifications
  const { emails, names } = extractMentions(text);
  const usersByEmail = await findUsersByEmails(emails);
  const usersByName = await findUsersByDisplayNames(names);

  const mentionedUids = [...new Set([
    ...usersByEmail.map(u => u.uid),
    ...usersByName.map(u => u.uid),
  ])].filter(uid => uid && uid !== user.uid);

  const snippet = text.length > 180 ? text.slice(0, 177) + '...' : text;

  const notifCount = await createNotifications({
    toUids: mentionedUids,
    payload: {
      taskId,
      taskTitle: task.title || '',
      byEmail: user.email || '',
      byName: authorName || '',
      snippet
    }
  });

  return json(event, 200, {
    ok: true,
    commentId: cRef.id,
    mentions: { emails, names, notified: mentionedUids.length },
    notificationsCreated: notifCount
  });
});

       --- File Content End ---


    =� tasks_bulkUpdate.js

       --- File Content Start ---

// netlify/functions/tasks_bulkUpdate.js
const { withCors, json, db, admin, auditLog, calendar } = require('./_common');
const { requireUser } = require('./_auth');

const ACTIVE_STATUSES = new Set(['PENDING','IN_PROGRESS','CLIENT_PENDING','APPROVAL_PENDING','COMPLETED']);

function chunk(arr, size) {
  const out = [];
  for (let i = 0; i < arr.length; i += size) out.push(arr.slice(i, i + size));
  return out;
}

function mustArrayIds(x) {
  if (!Array.isArray(x)) return [];
  return x.map(v => String(v || '').trim()).filter(Boolean);
}

function normEmail(x) {
  return String(x || '').trim();
}

function roleOf(user) {
  let r = String(user?.role || 'ASSOCIATE').toUpperCase().trim();
  if (r === 'WORKER') r = 'ASSOCIATE'; // compat
  return r || 'ASSOCIATE';
}

function isPrivileged(role) {
  return role === 'PARTNER' || role === 'MANAGER';
}

async function findUserUidByEmail(email) {
  const e = String(email || '').trim().toLowerCase();
  if (!e) return null;
  let snap = await db().collection('users').where('emailLower', '==', e).limit(1).get();
  if (snap.empty) snap = await db().collection('users').where('email', '==', email).limit(1).get();
  if (snap.empty) return null;
  return snap.docs[0].id;
}

async function safeDeleteCalendarEvent(eventId) {
  if (!eventId) return { ok:false, skipped:true };
  try {
    await calendar().events.delete({
      calendarId: 'primary',
      eventId,
      sendUpdates: 'none'
    });
    return { ok:true };
  } catch (e) {
    return { ok:false, error: e?.message || String(e) };
  }
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const body = JSON.parse(event.body || '{}');
  const op = String(body.op || '').toUpperCase().trim();
  const taskIds = mustArrayIds(body.taskIds);

  if (!op) return json(event, 400, { ok:false, error:'op required' });
  if (!taskIds.length) return json(event, 400, { ok:false, error:'taskIds required' });
  if (taskIds.length > 2000) return json(event, 400, { ok:false, error:'Too many tasks (max 2000)' });

  const role = roleOf(user);
  const privileged = isPrivileged(role);

  // Load tasks
  const refs = taskIds.map(id => db().collection('tasks').doc(id));
  const snaps = await db().getAll(...refs);
  const tasks = snaps.filter(s => s.exists).map(s => ({ id: s.id, ref: s.ref, data: s.data() }));

  if (!tasks.length) return json(event, 404, { ok:false, error:'No tasks found' });

  // Associate: only their tasks
  if (!privileged) {
    const notMine = tasks.filter(t => t.data.assignedToUid !== user.uid);
    if (notMine.length) return json(event, 403, { ok:false, error:'Some selected tasks are not assigned to you' });
  }

  let updatePatch = null;
  let updatedCount = 0;
  let deletedCount = 0;

  if (op === 'STATUS') {
    const newStatus = String(body.newStatus || '').toUpperCase().trim();
    if (!ACTIVE_STATUSES.has(newStatus)) return json(event, 400, { ok:false, error:'Invalid newStatus' });

    if (!privileged && newStatus === 'COMPLETED') {
      return json(event, 403, { ok:false, error:'Only Partner/Manager can mark COMPLETED' });
    }

    updatePatch = () => {
      const patch = {
        status: newStatus,
        updatedAt: admin.firestore.FieldValue.serverTimestamp()
      };
      if (newStatus === 'APPROVAL_PENDING') patch.completedRequestedAt = admin.firestore.FieldValue.serverTimestamp();
      if (newStatus === 'COMPLETED') patch.completedAt = admin.firestore.FieldValue.serverTimestamp();
      return patch;
    };

  } else if (op === 'REASSIGN') {
    const assignedToEmail = normEmail(body.assignedToEmail);
    if (!assignedToEmail) return json(event, 400, { ok:false, error:'assignedToEmail required' });

    const assignedToUid = await findUserUidByEmail(assignedToEmail);
    if (!assignedToUid) return json(event, 400, { ok:false, error:'assignedToEmail not found in users' });

    // Associates cannot reassign
    if (!privileged) return json(event, 403, { ok:false, error:'Only Partner/Manager can reassign' });

    updatePatch = () => ({
      assignedToEmail,
      assignedToUid,
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });

  } else if (op === 'SNOOZE') {
    const snoozedUntilYmd = String(body.snoozedUntilYmd || '').trim();
    if (!/^\d{4}-\d{2}-\d{2}$/.test(snoozedUntilYmd)) {
      return json(event, 400, { ok:false, error:'snoozedUntilYmd must be YYYY-MM-DD' });
    }

    updatePatch = () => ({
      snoozedUntilYmd,
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });

  } else if (op === 'DELETE') {
    // handled below

  } else {
    return json(event, 400, { ok:false, error:'Invalid op' });
  }

  // Apply in batches
  const batches = chunk(tasks, 350);

  for (const group of batches) {
    if (op === 'DELETE') {
      for (const t of group) {
        const singleId = t.data.calendarEventId || t.data.calendarStartEventId || null;
        const dueId = t.data.calendarDueEventId || null;

        await safeDeleteCalendarEvent(singleId);
        await safeDeleteCalendarEvent(dueId);

        await t.ref.delete();
        deletedCount++;

        await auditLog({
          taskId: t.id,
          action: 'TASK_DELETED_BULK',
          actorUid: user.uid,
          actorEmail: user.email,
          details: { op:'DELETE' }
        });

        await new Promise(res => setTimeout(res, 40));
      }
      continue;
    }

    const batch = db().batch();
    for (const t of group) batch.update(t.ref, updatePatch(t));
    await batch.commit();
    updatedCount += group.length;

    for (const t of group) {
      await auditLog({
        taskId: t.id,
        action:
          op === 'STATUS' ? 'BULK_STATUS_CHANGE' :
          op === 'REASSIGN' ? 'BULK_REASSIGN' :
          op === 'SNOOZE' ? 'BULK_SNOOZE' :
          'BULK_UPDATE',
        actorUid: user.uid,
        actorEmail: user.email,
        details: {
          op,
          ...(op === 'STATUS' ? { to: String(body.newStatus||'') } : {}),
          ...(op === 'REASSIGN' ? { assignedToEmail: String(body.assignedToEmail||'') } : {}),
          ...(op === 'SNOOZE' ? { snoozedUntilYmd: String(body.snoozedUntilYmd||'') } : {})
        }
      });
    }
  }

  return json(event, 200, {
    ok: true,
    op,
    requested: taskIds.length,
    found: tasks.length,
    updatedCount,
    deletedCount
  });
});

       --- File Content End ---


    =� tasks_bulkimportcsv.js

       --- File Content Start ---

// netlify/functions/tasks_bulkimportcsv.js
const {
  withCors, json, db, admin,
  calendar, ymdIST, dateFromYmdIST, addDays, addInterval,
  getCalendarWindow, calTimeRange,
  auditLog, asEmailList
} = require('./_common');
const { requireUser } = require('./_auth');

function roleOf(user) {
  let r = String(user?.role || 'ASSOCIATE').toUpperCase().trim();
  if (r === 'WORKER') r = 'ASSOCIATE'; // compat
  return r || 'ASSOCIATE';
}
function isPrivileged(role) {
  return role === 'PARTNER' || role === 'MANAGER';
}

async function findOrCreateClientByIdOrName({ clientId, clientName, clientEmail }) {
  if (clientId) {
    const cRef = db().collection('clients').doc(clientId);
    const cSnap = await cRef.get();
    if (!cSnap.exists) throw new Error('Client not found: ' + clientId);
    if (clientEmail && !cSnap.data().primaryEmail) await cRef.update({ primaryEmail: clientEmail });
    return clientId;
  }
  if (!clientName) throw new Error('clientId or clientName required');

  const snap = await db().collection('clients').where('name', '==', clientName).limit(1).get();
  if (!snap.empty) {
    const id = snap.docs[0].id;
    const cRef = db().collection('clients').doc(id);
    const cSnap = await cRef.get();
    if (clientEmail && cSnap.exists && !cSnap.data().primaryEmail) await cRef.update({ primaryEmail: clientEmail });
    return id;
  }

  const ref = db().collection('clients').doc();
  await ref.set({
    name: clientName,
    primaryEmail: clientEmail || '',
    ccEmails: [],
    bccEmails: [],
    createdAt: admin.firestore.FieldValue.serverTimestamp()
  });
  return ref.id;
}

async function findUserUidByEmail(email) {
  if (!email) return null;
  const e = String(email).trim().toLowerCase();
  let snap = await db().collection('users').where('emailLower', '==', e).limit(1).get();
  if (snap.empty) snap = await db().collection('users').where('email', '==', email).limit(1).get();
  if (snap.empty) return null;
  return snap.docs[0].id;
}

function normalizeRecurrence(x) {
  const r = String(x || 'AD_HOC').toUpperCase().trim();
  const allowed = ['AD_HOC','DAILY','WEEKLY','BIWEEKLY','MONTHLY','BIMONTHLY','QUARTERLY','HALF_YEARLY','YEARLY'];
  return allowed.includes(r) ? r : 'AD_HOC';
}

function normalizeCategory(x) {
  const raw = String(x || 'OTHER').trim();
  const u = raw.toUpperCase().replace(/\s+/g, '_');
  if (u === 'ITR' || u === 'INCOME_TAX' || u === 'INCOME-TAX' || u === 'INCOME' || u === 'INCOME_TAX_RETURN') return 'INCOME_TAX';
  if (u === 'GST') return 'GST';
  if (u === 'TDS') return 'TDS';
  if (u === 'ROC') return 'ROC';
  if (u === 'ACCOUNTING') return 'ACCOUNTING';
  if (u === 'AUDIT') return 'AUDIT';
  return 'OTHER';
}

function normalizePriority(x) {
  const v = String(x || 'MEDIUM').trim().toUpperCase();
  if (v === 'HIGH' || v === 'LOW') return v;
  return 'MEDIUM';
}

async function createStartCalendarEvent({ title, clientId, startDateYmd, dueDateYmd, window }) {
  const cal = calendar();
  const range = calTimeRange(startDateYmd, window.startHH, window.endHH, window.timeZone);
  const res = await cal.events.insert({
    calendarId: 'primary',
    sendUpdates: 'none',
    requestBody: {
      summary: `START: ${title}`,
      description:
        `ClientId: ${clientId}\n` +
        `Start: ${startDateYmd}\n` +
        `Due: ${dueDateYmd}\n`,
      ...range
    }
  });
  return { calendarEventId: res.data.id, calendarHtmlLink: res.data.htmlLink || null };
}

/**
 * This endpoint is a JSON bulk importer (legacy name).
 * It is kept for backward compatibility and now supports the new mail flags/fields too.
 *
 * Request body (example):
 * {
 *   clientId?, clientName?, clientEmail?,
 *   title, dueDateYmd,
 *   category, type, priority,
 *   recurrence, generateCount, triggerDaysBefore,
 *   assignedToEmail,
 *   sendClientStartMail, clientToEmails, clientCcEmails, clientBccEmails,
 *   ccAssigneeOnClientStart, ccManagerOnClientStart,
 *   clientStartSubject, clientStartBody,
 *   sendClientCompletionMail, clientCompletionSubject, clientCompletionBody,
 *   completionToEmails, completionCcEmails, completionBccEmails,
 *   ccAssigneeOnCompletion, ccManagerOnCompletion
 * }
 */
exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const role = roleOf(user);
  const privileged = isPrivileged(role);

  // For safety: only Partner/Manager should use this legacy JSON import
  if (!privileged) {
    return json(event, 403, { ok:false, error:'Partner/Manager only' });
  }

  const body = JSON.parse(event.body || '{}');

  const clientId = await findOrCreateClientByIdOrName({
    clientId: body.clientId || null,
    clientName: body.clientName || null,
    clientEmail: body.clientEmail || null,
  });

  const title = body.title || 'Untitled';

  const dueDateYmd = String(body.dueDateYmd || '').trim();
  if (!/^\d{4}-\d{2}-\d{2}$/.test(dueDateYmd)) {
    return json(event, 400, { ok:false, error:'dueDateYmd required (YYYY-MM-DD)' });
  }

  const recurrence = normalizeRecurrence(body.recurrence || 'AD_HOC');
  const generateCount = Math.max(1, parseInt(body.generateCount || '1', 10));
  const triggerDaysBefore = Math.max(0, parseInt(body.triggerDaysBefore ?? 15, 10));

  const assignedToEmail = (body.assignedToEmail || user.email || '').trim();
  const assignedToUid = (await findUserUidByEmail(assignedToEmail)) || user.uid;

  const category = normalizeCategory(body.category || 'OTHER');
  const type = String(body.type || 'FILING').trim();
  const priority = normalizePriority(body.priority || 'MEDIUM');

  // Mail flags + templates + recipients
  const sendClientStartMail = (body.sendClientStartMail !== false);
  const clientToEmails = asEmailList(body.clientToEmails || body.clientTo || body.clientEmail || null);
  const clientCcEmails = asEmailList(body.clientCcEmails || body.clientCc || null);
  const clientBccEmails = asEmailList(body.clientBccEmails || body.clientBcc || null);
  const ccAssigneeOnClientStart = body.ccAssigneeOnClientStart === true;
  const ccManagerOnClientStart = body.ccManagerOnClientStart === true;
  const clientStartSubject = String(body.clientStartSubject || '').trim();
  const clientStartBody = String(body.clientStartBody || '').trim();

  const sendClientCompletionMail = body.sendClientCompletionMail !== false;
  const clientCompletionSubject = String(body.clientCompletionSubject || '').trim();
  const clientCompletionBody = String(body.clientCompletionBody || '').trim();

  const completionToEmails = asEmailList(body.completionToEmails || body.completionTo || null);
  const completionCcEmails = asEmailList(body.completionCcEmails || body.completionCc || null);
  const completionBccEmails = asEmailList(body.completionBccEmails || body.completionBcc || null);
  const ccAssigneeOnCompletion = body.ccAssigneeOnCompletion === true;
  const ccManagerOnCompletion = body.ccManagerOnCompletion === true;

  const isSeries = recurrence !== 'AD_HOC' && generateCount > 1;
  const seriesId = isSeries ? db().collection('taskSeries').doc().id : null;

  const window = await getCalendarWindow();
  let created = 0;

  for (let i = 0; i < generateCount; i++) {
    const dueDate = addInterval(dateFromYmdIST(dueDateYmd), recurrence, i);
    const dueYmd = ymdIST(dueDate);
    const startDate = addDays(dateFromYmdIST(dueYmd), -triggerDaysBefore);
    const startYmd = ymdIST(startDate);

    const ev = await createStartCalendarEvent({
      title, clientId, startDateYmd: startYmd, dueDateYmd: dueYmd, window
    });

    const tRef = db().collection('tasks').doc();
    await tRef.set({
      clientId,
      title,
      category,
      type,
      priority,

      recurrence,
      seriesId,
      occurrenceIndex: i + 1,
      occurrenceTotal: generateCount,

      dueDate: admin.firestore.Timestamp.fromDate(dateFromYmdIST(dueYmd)),
      dueDateYmd: dueYmd,
      triggerDaysBefore,

      startDate: admin.firestore.Timestamp.fromDate(dateFromYmdIST(startYmd)),
      startDateYmd: startYmd,

      assignedToUid,
      assignedToEmail,

      status: 'PENDING',
      statusNote: '',
      delayReason: null,
      delayNotes: '',
      snoozedUntilYmd: null,

      calendarEventId: ev.calendarEventId,
      calendarHtmlLink: ev.calendarHtmlLink || null,
      calendarStartEventId: ev.calendarEventId,
      calendarDueEventId: null,

      // Start mail
      sendClientStartMail,
      clientToEmails,
      clientCcEmails,
      clientBccEmails,
      ccAssigneeOnClientStart,
      ccManagerOnClientStart,
      clientStartSubject,
      clientStartBody,
      clientStartMailSent: false,
      clientStartMailSentAt: null,
      clientStartGmailThreadId: null,
      clientStartGmailId: null,
      clientStartRfcMessageId: null,
      clientStartReferences: null,

      // Completion mail + overrides
      sendClientCompletionMail,
      clientCompletionSubject,
      clientCompletionBody,
      completionToEmails,
      completionCcEmails,
      completionBccEmails,
      ccAssigneeOnCompletion,
      ccManagerOnCompletion,

      createdByUid: user.uid,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      completedRequestedAt: null,
      completedAt: null,
      attachments: []
    });

    await auditLog({
      taskId: tRef.id,
      action: 'TASK_CREATED',
      actorUid: user.uid,
      actorEmail: user.email,
      details: { source:'JSON_IMPORT', seriesId, occurrenceIndex: i+1, startDateYmd: startYmd, dueDateYmd: dueYmd }
    });

    created++;
  }

  return json(event, 200, { ok:true, created, seriesId });
});

       --- File Content End ---


    =� tasks_bulkimportxlsx.js

       --- File Content Start ---

// netlify/functions/tasks_bulkimportxlsx.js
const Busboy = require('busboy');
const ExcelJS = require('exceljs');
const crypto = require('crypto');

const {
  withCors, json, db, admin,
  dmyToYmd, ymdIST, dateFromYmdIST,
  addInterval, addDays,
  getCalendarWindow,
  auditLog, asEmailList,
  createStartCalendarEvent, trySendStartMailImmediately
} = require('./_common');
const { requireUser } = require('./_auth');

// ===== Worker(import) password verify (PBKDF2) =====
function pbkdf2Hash(password, saltBuf, iter) {
  const keyLen = 32;
  const digest = 'sha256';
  return crypto.pbkdf2Sync(password, saltBuf, iter, keyLen, digest);
}
async function verifyWorkerImportPassword(plainPassword) {
  const sSnap = await db().collection('settings').doc('security').get();
  if (!sSnap.exists) return false;
  const s = sSnap.data() || {};
  if (s.workerImportEnabled !== true) return false;
  if (!s.workerImportHash || !s.workerImportSalt || !s.workerImportIter) return false;

  const salt = Buffer.from(String(s.workerImportSalt), 'base64');
  const iter = Number(s.workerImportIter || 0);
  const expected = Buffer.from(String(s.workerImportHash), 'base64');

  if (!salt.length || !iter || !expected.length) return false;

  const got = pbkdf2Hash(String(plainPassword || ''), salt, iter);
  if (got.length !== expected.length) return false;
  return crypto.timingSafeEqual(got, expected);
}

// ===== Helpers =====
async function findOrCreateClientByName(clientName) {
  const snap = await db().collection('clients').where('name', '==', clientName).limit(1).get();
  if (!snap.empty) return { id: snap.docs[0].id, data: snap.docs[0].data() };

  const ref = db().collection('clients').doc();
  const newData = {
    name: clientName,
    pan: '', gstin: '', cin: '',
    assessmentYear: '', engagementType: '',
    primaryEmail: '',
    ccEmails: [], bccEmails: [],
    driveFolderId: null,
    createdAt: admin.firestore.FieldValue.serverTimestamp()
  };
  await ref.set(newData);
  return { id: ref.id, data: newData };
}

async function findUserUidByEmail(email) {
  if (!email) return null;
  const e = String(email).trim().toLowerCase();
  let snap = await db().collection('users').where('emailLower', '==', e).limit(1).get();
  if (snap.empty) snap = await db().collection('users').where('email', '==', email).limit(1).get();
  if (snap.empty) return null;
  return snap.docs[0].id;
}

function normalizeRecurrence(x) {
  const r = String(x || 'AD_HOC').toUpperCase().trim();
  const allowed = ['AD_HOC','DAILY','WEEKLY','BIWEEKLY','MONTHLY','BIMONTHLY','QUARTERLY','HALF_YEARLY','YEARLY'];
  return allowed.includes(r) ? r : 'AD_HOC';
}
function normalizeCategory(x) {
  const raw = String(x || 'OTHER').trim();
  const u = raw.toUpperCase().replace(/\s+/g, '_');
  if (u === 'ITR' || u === 'INCOME_TAX' || u === 'INCOME-TAX' || u === 'INCOME' || u === 'INCOME_TAX_RETURN') return 'INCOME_TAX';
  if (String(x).trim().toLowerCase() === 'income tax') return 'INCOME_TAX';
  if (u === 'GST') return 'GST';
  if (u === 'TDS') return 'TDS';
  if (u === 'ROC') return 'ROC';
  if (u === 'ACCOUNTING') return 'ACCOUNTING';
  if (u === 'AUDIT') return 'AUDIT';
  return 'OTHER';
}
function normalizePriority(x) {
  const v = String(x || 'MEDIUM').trim().toUpperCase();
  if (v === 'HIGH' || v === 'LOW') return v;
  return 'MEDIUM';
}
function truthy(x) {
  const s = String(x ?? '').trim().toLowerCase();
  if (!s) return false;
  return ['1','true','yes','y'].includes(s);
}
function getCellString(cell) {
  if (!cell) return '';
  const v = cell.value;
  if (v == null) return '';
  if (typeof v === 'string') return v.trim();
  if (typeof v === 'number') return String(v);
  if (v instanceof Date) return v.toISOString();
  if (typeof v === 'object') {
    if (v.text) return String(v.text).trim();
    if (v.richText && Array.isArray(v.richText)) return v.richText.map(r => r.text || '').join('').trim();
  }
  return String(v).trim();
}
function parseDueDateDmyFromExcel(cell) {
  if (!cell || cell.value == null) return null;
  const v = cell.value;
  if (v instanceof Date) {
    const yyyy = v.getFullYear();
    const mm = String(v.getMonth() + 1).padStart(2,'0');
    const dd = String(v.getDate()).padStart(2,'0');
    return `${dd}-${mm}-${yyyy}`;
  }
  const s = getCellString(cell);
  return s || null;
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  // Parse multipart
  const busboy = Busboy({ headers: event.headers });
  let fileBuffer = Buffer.alloc(0);
  let importPassword = '';

  busboy.on('field', (name, val) => {
    if (name === 'importPassword') importPassword = String(val || '');
  });
  busboy.on('file', (name, file) => {
    file.on('data', (d) => { fileBuffer = Buffer.concat([fileBuffer, d]); });
  });

  const done = new Promise((resolve, reject) => {
    busboy.on('finish', resolve);
    busboy.on('error', reject);
  });
  const bodyBuf = event.isBase64Encoded ? Buffer.from(event.body, 'base64') : Buffer.from(event.body || '');
  busboy.end(bodyBuf);
  await done;

  if (!fileBuffer.length) return json(event, 400, { ok:false, error:'XLSX file missing' });

  // Authorization:
  // - PARTNER/MANAGER can import
  // - ASSOCIATE can import only if importPassword matches settings/security
  const role = String(user.role || 'ASSOCIATE').toUpperCase().trim();
  const privileged = (role === 'PARTNER' || role === 'MANAGER');

  if (!privileged) {
    const okPwd = await verifyWorkerImportPassword(importPassword);
    if (!okPwd) {
      return json(event, 403, { ok:false, error:'Associate import password required or incorrect' });
    }
  }

  const wb = new ExcelJS.Workbook();
  await wb.xlsx.load(fileBuffer);
  const ws = wb.getWorksheet('Import') || wb.worksheets[0];
  if (!ws) return json(event, 400, { ok:false, error:'No worksheet found' });

  const headerRow = ws.getRow(1);
  const headers = {};
  headerRow.eachCell((cell, colNumber) => {
    const key = getCellString(cell);
    if (key) headers[key] = colNumber;
  });
  function colOf(names) {
    for (const n of names) { if (headers[n]) return headers[n]; }
    return null;
  }

  const cTitle = colOf(['Title']);
  const cClient = colOf(['Client']);
  const cClientEmail = colOf(['ClientEmail']);
  const cDue = colOf(['DueDate (DD-MM-YYYY)','DueDate','Due']);
  const cCategory = colOf(['Category']);
  const cType = colOf(['Type (you can type custom)','Type']);
  const cRec = colOf(['Recurrence']);
  const cGen = colOf(['GenerateCount']);
  const cTrig = colOf(['TriggerDays']);
  const cAssigned = colOf(['AssignedToEmail']);
  const cPriority = colOf(['Priority']);

  const cTo = colOf(['ClientTo (emails ; , : separated)','ClientTo']);
  const cCc = colOf(['ClientCC (emails ; , : separated)','ClientCC']);
  const cBcc = colOf(['ClientBCC (emails ; , : separated)','ClientBCC']);
  const cStartSub = colOf(['ClientStartSubject']);
  const cStartBody = colOf(['ClientStartBody']);
  const cSendStart = colOf(['SendStartMail (true/false)','SendStartMail','SendClientStartMail (true/false)','SendClientStartMail']);
  const cCcAssignee = colOf(['CcAssigneeOnClientStart (true/false)','CcAssigneeOnClientStart']);
  const cCcManager = colOf(['CcManagerOnClientStart (true/false)','CcManagerOnClientStart']);

  const cSendComp = colOf(['SendClientCompletionMail (true/false)','SendClientCompletionMail']);
  const cCompSub = colOf(['ClientCompletionSubject']);
  const cCompBody = colOf(['ClientCompletionBody']);

  // NEW: completion overrides
  const cCompTo = colOf(['CompletionTo (emails ; , : separated)','CompletionTo']);
  const cCompCc = colOf(['CompletionCC (emails ; , : separated)','CompletionCC']);
  const cCompBcc = colOf(['CompletionBCC (emails ; , : separated)','CompletionBCC']);
  const cCcAssigneeComp = colOf(['CcAssigneeOnCompletion (true/false)','CcAssigneeOnCompletion']);
  const cCcManagerComp = colOf(['CcManagerOnCompletion (true/false)','CcManagerOnCompletion']);

  if (!cTitle || !cClient || !cDue) {
    return json(event, 400, { ok:false, error:'Missing required columns (Title, Client, DueDate)' });
  }

  const window = await getCalendarWindow();
  const todayYmd = ymdIST(new Date());

  let created = 0;
  const seriesIdsCreated = new Set();

  const startRow = 2;
  const lastRow = ws.lastRow ? ws.lastRow.number : 1;

  for (let r = startRow; r <= lastRow; r++) {
    const row = ws.getRow(r);

    const title = getCellString(row.getCell(cTitle));
    const clientName = getCellString(row.getCell(cClient));
    const dueDmy = parseDueDateDmyFromExcel(row.getCell(cDue));
    if (!title || !clientName || !dueDmy) continue;

    const dueBaseYmd = dmyToYmd(dueDmy);
    const dueBase = dateFromYmdIST(dueBaseYmd);

    const recurrence = normalizeRecurrence(getCellString(row.getCell(cRec)) || 'AD_HOC');
    const generateCount = Math.max(1, parseInt(getCellString(row.getCell(cGen)) || '1', 10));
    const triggerDaysBefore = Math.max(0, parseInt(getCellString(row.getCell(cTrig)) || '15', 10));

    const category = normalizeCategory(getCellString(row.getCell(cCategory)) || 'OTHER');
    const type = getCellString(row.getCell(cType)) || 'FILING';
    const priority = cPriority ? normalizePriority(getCellString(row.getCell(cPriority))) : 'MEDIUM';

    const assignedEmail = (getCellString(row.getCell(cAssigned)) || '').trim() || null;
    const clientEmail = (getCellString(row.getCell(cClientEmail)) || '').trim() || null;

    const clientToEmails = asEmailList(getCellString(row.getCell(cTo)) || clientEmail || null);
    const clientCcEmails = asEmailList(getCellString(row.getCell(cCc)) || null);
    const clientBccEmails = asEmailList(getCellString(row.getCell(cBcc)) || null);

    const clientStartSubject = getCellString(row.getCell(cStartSub)) || '';
    const clientStartBody = getCellString(row.getCell(cStartBody)) || '';

    const sendClientStartMail = (cSendStart ? truthy(getCellString(row.getCell(cSendStart)) || 'true') : true);
    const ccAssigneeOnClientStart = cCcAssignee ? truthy(getCellString(row.getCell(cCcAssignee)) || 'false') : false;
    const ccManagerOnClientStart = cCcManager ? truthy(getCellString(row.getCell(cCcManager)) || 'false') : false;

    const sendClientCompletionMail = (cSendComp ? truthy(getCellString(row.getCell(cSendComp)) || 'true') : true);
    const clientCompletionSubject = getCellString(row.getCell(cCompSub)) || '';
    const clientCompletionBody = getCellString(row.getCell(cCompBody)) || '';

    const completionToEmails = asEmailList(getCellString(row.getCell(cCompTo)) || null);
    const completionCcEmails = asEmailList(getCellString(row.getCell(cCompCc)) || null);
    const completionBccEmails = asEmailList(getCellString(row.getCell(cCompBcc)) || null);
    const ccAssigneeOnCompletion = cCcAssigneeComp ? truthy(getCellString(row.getCell(cCcAssigneeComp)) || 'false') : false;
    const ccManagerOnCompletion = cCcManagerComp ? truthy(getCellString(row.getCell(cCcManagerComp)) || 'false') : false;

    // Client get/create
    const { id: clientId, data: clientData0 } = await findOrCreateClientByName(clientName);
    const clientData = { ...(clientData0 || {}) };

    if (clientEmail && !clientData.primaryEmail) {
      await db().collection('clients').doc(clientId).update({ primaryEmail: clientEmail });
      clientData.primaryEmail = clientEmail;
    }

    // Assignee rules
    let assignedToUid = null;
    let assignedToEmailFinal = assignedEmail || user.email;

    if (!privileged) {
      // Associate import: force to self
      assignedToUid = user.uid;
      assignedToEmailFinal = user.email;
    } else {
      assignedToUid = (await findUserUidByEmail(assignedEmail)) || user.uid;
      if (!assignedToUid) assignedToUid = user.uid;
      if (!assignedEmail) assignedToEmailFinal = user.email;
    }

    const isSeries = recurrence !== 'AD_HOC' && generateCount > 1;
    const seriesId = isSeries ? db().collection('taskSeries').doc().id : null;
    if (seriesId) seriesIdsCreated.add(seriesId);

    for (let i = 0; i < generateCount; i++) {
      const dueDate = addInterval(dueBase, recurrence, i);
      const dueDateYmd = ymdIST(dueDate);
      const startDate = addDays(dateFromYmdIST(dueDateYmd), -triggerDaysBefore);
      const startDateYmd = ymdIST(startDate);

      const ev = await createStartCalendarEvent({
        title, clientId, startDateYmd, dueDateYmd, window
      });

      // immediate mail if start is today
      const taskMailObj = {
        title,
        startDateYmd,
        dueDateYmd,
        sendClientStartMail,
        clientStartSubject,
        clientStartBody,
        clientToEmails, clientCcEmails, clientBccEmails,
        ccAssigneeOnClientStart,
        ccManagerOnClientStart,
        assignedToEmail: assignedToEmailFinal,
        assignedToUid
      };

      let mailResult = null;
      if (startDateYmd === todayYmd) {
        mailResult = await trySendStartMailImmediately({
          task: taskMailObj,
          client: clientData,
          window
        });
      }

      const tRef = db().collection('tasks').doc();
      await tRef.set({
        clientId,
        title,
        category,
        type,
        priority,
        recurrence,
        seriesId,
        occurrenceIndex: i + 1,
        occurrenceTotal: generateCount,

        dueDate: admin.firestore.Timestamp.fromDate(dateFromYmdIST(dueDateYmd)),
        dueDateYmd,
        triggerDaysBefore,

        startDate: admin.firestore.Timestamp.fromDate(dateFromYmdIST(startDateYmd)),
        startDateYmd,

        assignedToUid,
        assignedToEmail: assignedToEmailFinal,

        status: 'PENDING',
        statusNote: '',
        delayReason: null,
        delayNotes: '',
        snoozedUntilYmd: null,

        calendarEventId: ev.calendarEventId,
        calendarHtmlLink: ev.calendarHtmlLink || null,
        calendarStartEventId: ev.calendarEventId,
        calendarDueEventId: null,

        // Start mail fields
        sendClientStartMail,
        clientToEmails, clientCcEmails, clientBccEmails,
        ccAssigneeOnClientStart, ccManagerOnClientStart,
        clientStartSubject,
        clientStartBody,
        clientStartMailSent: mailResult ? true : false,
        clientStartMailSentAt: mailResult?.clientStartMailSentAt || null,
        clientStartGmailThreadId: mailResult?.clientStartGmailThreadId || null,
        clientStartGmailId: mailResult?.clientStartGmailId || null,
        clientStartRfcMessageId: mailResult?.clientStartRfcMessageId || null,
        clientStartReferences: mailResult?.clientStartReferences || null,

        // Completion mail fields + overrides
        sendClientCompletionMail,
        clientCompletionSubject,
        clientCompletionBody,
        completionToEmails,
        completionCcEmails,
        completionBccEmails,
        ccAssigneeOnCompletion,
        ccManagerOnCompletion,

        createdByUid: user.uid,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        completedRequestedAt: null,
        completedAt: null,
        attachments: []
      });

      await auditLog({
        taskId: tRef.id,
        action: 'TASK_CREATED',
        actorUid: user.uid,
        actorEmail: user.email,
        details: {
          source: 'XLSX',
          seriesId,
          occurrenceIndex: i + 1,
          startDateYmd,
          sentMailNow: !!mailResult
        }
      });

      created++;
    }
  }

  return json(event, 200, {
    ok:true,
    created,
    seriesCreated: seriesIdsCreated.size
  });
});

       --- File Content End ---


    =� tasks_bulkupdate_from_xlsx.js

       --- File Content Start ---

// netlify/functions/tasks_bulkupdate_from_xlsx.js
const Busboy = require('busboy');
const ExcelJS = require('exceljs');

const {
  withCors, json, db, admin,
  dmyToYmd, ymdIST, addDays, dateFromYmdIST,
  getCalendarWindow, calTimeRange,
  auditLog, calendar
} = require('./_common');
const { requireUser } = require('./_auth');

function roleOf(user) {
  let r = String(user?.role || 'ASSOCIATE').toUpperCase().trim();
  if (r === 'WORKER') r = 'ASSOCIATE';
  return r || 'ASSOCIATE';
}
function isPrivileged(role) {
  return role === 'PARTNER' || role === 'MANAGER';
}

function asEmailListLoose(x) {
  if (Array.isArray(x)) return x.map(s => String(s).trim()).filter(Boolean);
  if (typeof x === 'string') return x.split(/[;,:]/).map(s => s.trim()).filter(Boolean);
  return [];
}

function getCellString(cell) {
  if (!cell) return '';
  const v = cell.value;
  if (v == null) return '';
  if (typeof v === 'string') return v.trim();
  if (typeof v === 'number') return String(v);
  if (v instanceof Date) return v.toISOString();
  if (typeof v === 'object') {
    if (v.text) return String(v.text).trim();
    if (v.richText && Array.isArray(v.richText)) return v.richText.map(r => r.text || '').join('').trim();
  }
  return String(v).trim();
}
function truthy(x) {
  const s = String(x ?? '').trim().toLowerCase();
  if (!s) return false;
  return ['1','true','yes','y'].includes(s);
}
function parseDmyCell(cell) {
  if (!cell || cell.value == null) return '';
  const v = cell.value;
  if (v instanceof Date) {
    const yyyy = v.getFullYear();
    const mm = String(v.getMonth() + 1).padStart(2,'0');
    const dd = String(v.getDate()).padStart(2,'0');
    return `${dd}-${mm}-${yyyy}`;
  }
  return getCellString(cell);
}

async function patchEvent({ eventId, whenYmd, summary, description, colorId=null, window }) {
  if (!eventId) return;
  const cal = calendar();
  const range = calTimeRange(whenYmd, window.startHH, window.endHH, window.timeZone);
  await cal.events.patch({
    calendarId: 'primary',
    eventId,
    sendUpdates: 'none',
    requestBody: {
      summary,
      description,
      ...range,
      ...(colorId ? { colorId } : {})
    }
  });
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const role = roleOf(user);
  const privileged = isPrivileged(role);

  // Parse multipart
  const busboy = Busboy({ headers: event.headers });
  let fileBuffer = Buffer.alloc(0);

  busboy.on('file', (name, file) => {
    file.on('data', (d) => { fileBuffer = Buffer.concat([fileBuffer, d]); });
  });

  const done = new Promise((resolve, reject) => {
    busboy.on('finish', resolve);
    busboy.on('error', reject);
  });

  const bodyBuf = event.isBase64Encoded ? Buffer.from(event.body, 'base64') : Buffer.from(event.body || '');
  busboy.end(bodyBuf);
  await done;

  if (!fileBuffer.length) return json(event, 400, { ok:false, error:'XLSX file missing' });

  const wb = new ExcelJS.Workbook();
  await wb.xlsx.load(fileBuffer);
  const ws = wb.getWorksheet('Update') || wb.worksheets[0];
  if (!ws) return json(event, 400, { ok:false, error:'No worksheet found' });

  // Header map
  const headerRow = ws.getRow(1);
  const headers = {};
  headerRow.eachCell((cell, colNumber) => {
    const key = getCellString(cell);
    if (key) headers[key] = colNumber;
  });
  const colOf = (names) => {
    for (const n of names) { if (headers[n]) return headers[n]; }
    return null;
  };

  const cTaskId = colOf(['TaskId']);
  if (!cTaskId) return json(event, 400, { ok:false, error:'Missing required column: TaskId' });

  // Optional columns
  const cTitle = colOf(['Title']);
  const cCategory = colOf(['Category']);
  const cType = colOf(['Type']);
  const cPriority = colOf(['Priority']);
  const cDue = colOf(['DueDate (DD-MM-YYYY)', 'DueDate']);
  const cTrigger = colOf(['TriggerDays']);
  const cAssigned = colOf(['AssignedToEmail']);
  const cStatus = colOf(['Status']);
  const cStatusNote = colOf(['StatusNote']);
  const cDelayReason = colOf(['DelayReason']);
  const cDelayNotes = colOf(['DelayNotes']);
  const cSnooze = colOf(['SnoozedUntil (DD-MM-YYYY)', 'SnoozedUntil']);

  const cSendStart = colOf(['SendStartMail (true/false)', 'SendStartMail']);
  const cTo = colOf(['ClientTo (emails ; , : separated)', 'ClientTo']);
  const cCc = colOf(['ClientCC (emails ; , : separated)', 'ClientCC']);
  const cBcc = colOf(['ClientBCC (emails ; , : separated)', 'ClientBCC']);
  const cCcAssignee = colOf(['CcAssigneeOnClientStart (true/false)', 'CcAssigneeOnClientStart']);
  const cCcManager = colOf(['CcManagerOnClientStart (true/false)', 'CcManagerOnClientStart']);
  const cStartSub = colOf(['ClientStartSubject']);
  const cStartBody = colOf(['ClientStartBody']);

  const cSendComp = colOf(['SendClientCompletionMail (true/false)', 'SendClientCompletionMail']);
  const cCompTo = colOf(['CompletionTo (emails ; , : separated)', 'CompletionTo']);
  const cCompCc = colOf(['CompletionCC (emails ; , : separated)', 'CompletionCC']);
  const cCompBcc = colOf(['CompletionBCC (emails ; , : separated)', 'CompletionBCC']);
  const cCcAssigneeComp = colOf(['CcAssigneeOnCompletion (true/false)', 'CcAssigneeOnCompletion']);
  const cCcManagerComp = colOf(['CcManagerOnCompletion (true/false)', 'CcManagerOnCompletion']);
  const cCompSub = colOf(['ClientCompletionSubject']);
  const cCompBody = colOf(['ClientCompletionBody']);

  const startRow = 2;
  const lastRow = ws.lastRow ? ws.lastRow.number : 1;

  const window = await getCalendarWindow();

  let updatedCount = 0;
  let skippedCount = 0;
  const errors = [];

  // Limit to prevent abuse
  const maxUpdates = 800;

  for (let r = startRow; r <= lastRow; r++) {
    if (updatedCount + skippedCount >= maxUpdates) break;

    const row = ws.getRow(r);
    const taskId = String(getCellString(row.getCell(cTaskId)) || '').trim();
    if (!taskId) continue;

    const ref = db().collection('tasks').doc(taskId);
    const snap = await ref.get();
    if (!snap.exists) {
      skippedCount++;
      errors.push({ row: r, taskId, error: 'Task not found' });
      continue;
    }

    const old = snap.data();

    // Permission: associate can update only own tasks; and only safe fields
    if (!privileged) {
      if (old.assignedToUid !== user.uid) {
        skippedCount++;
        errors.push({ row: r, taskId, error: 'Not allowed (not your task)' });
        continue;
      }
    }

    const patch = {};
    const changed = [];

    // Helpers to set patch only if cell not blank
    const setIf = (field, value, allowEmptyString = false) => {
      if (value === undefined) return;
      if (!allowEmptyString && value === '') return;
      patch[field] = value;
      changed.push(field);
    };

    // Fields (privileged only for many)
    if (cTitle && privileged) setIf('title', getCellString(row.getCell(cTitle)));
    if (cCategory && privileged) setIf('category', getCellString(row.getCell(cCategory)));
    if (cType && privileged) setIf('type', getCellString(row.getCell(cType)));
    if (cPriority) setIf('priority', (getCellString(row.getCell(cPriority)) || '').toUpperCase());

    // Due date + trigger affects startDate + calendar patch (privileged only)
    let dueDateYmd = null;
    if (cDue && privileged) {
      const dueDmy = parseDmyCell(row.getCell(cDue));
      if (dueDmy) {
        try {
          dueDateYmd = dmyToYmd(dueDmy);
          patch.dueDateYmd = dueDateYmd;
          patch.dueDate = admin.firestore.Timestamp.fromDate(dateFromYmdIST(dueDateYmd));
          changed.push('dueDateYmd', 'dueDate');
        } catch (e) {
          skippedCount++;
          errors.push({ row: r, taskId, error: `Invalid due date: ${e.message}` });
          continue;
        }
      }
    }

    let triggerDaysBefore = null;
    if (cTrigger && privileged) {
      const v = getCellString(row.getCell(cTrigger));
      if (v) {
        const n = Math.max(0, parseInt(v, 10));
        triggerDaysBefore = n;
        patch.triggerDaysBefore = n;
        changed.push('triggerDaysBefore');
      }
    }

    // Reassign (privileged only)
    if (cAssigned && privileged) {
      const email = getCellString(row.getCell(cAssigned)).trim();
      if (email) {
        // best-effort lookup
        const q = await db().collection('users').where('emailLower', '==', email.toLowerCase()).limit(1).get();
        if (q.empty) {
          skippedCount++;
          errors.push({ row: r, taskId, error: 'AssignedToEmail not found in users' });
          continue;
        }
        patch.assignedToEmail = email;
        patch.assignedToUid = q.docs[0].id;
        changed.push('assignedToEmail', 'assignedToUid');
      }
    }

    // Status + notes (associates allowed, but COMPLETED only privileged)
    if (cStatus) {
      const st = getCellString(row.getCell(cStatus)).toUpperCase().trim();
      if (st) {
        if (!privileged && st === 'COMPLETED') {
          skippedCount++;
          errors.push({ row: r, taskId, error: 'Associates cannot mark COMPLETED' });
          continue;
        }
        patch.status = st;
        changed.push('status');
        if (st === 'APPROVAL_PENDING') {
          patch.completedRequestedAt = admin.firestore.FieldValue.serverTimestamp();
          changed.push('completedRequestedAt');
        }
        if (st === 'COMPLETED') {
          patch.completedAt = admin.firestore.FieldValue.serverTimestamp();
          changed.push('completedAt');
        }
      }
    }

    if (cStatusNote) setIf('statusNote', getCellString(row.getCell(cStatusNote)), true);
    if (cDelayReason) setIf('delayReason', getCellString(row.getCell(cDelayReason)), true);
    if (cDelayNotes) setIf('delayNotes', getCellString(row.getCell(cDelayNotes)), true);

    // Snooze (associates allowed)
    if (cSnooze) {
      const snoozeDmy = parseDmyCell(row.getCell(cSnooze));
      if (snoozeDmy) {
        try {
          const y = dmyToYmd(snoozeDmy);
          patch.snoozedUntilYmd = y;
          changed.push('snoozedUntilYmd');
        } catch (e) {
          skippedCount++;
          errors.push({ row: r, taskId, error: `Invalid snooze date: ${e.message}` });
          continue;
        }
      }
    }

    // Mail fields (privileged only)
    if (privileged) {
      if (cSendStart) {
        const v = getCellString(row.getCell(cSendStart));
        if (v) { patch.sendClientStartMail = truthy(v); changed.push('sendClientStartMail'); }
      }
      if (cTo) { const v = getCellString(row.getCell(cTo)); if (v) { patch.clientToEmails = asEmailListLoose(v); changed.push('clientToEmails'); } }
      if (cCc) { const v = getCellString(row.getCell(cCc)); if (v) { patch.clientCcEmails = asEmailListLoose(v); changed.push('clientCcEmails'); } }
      if (cBcc) { const v = getCellString(row.getCell(cBcc)); if (v) { patch.clientBccEmails = asEmailListLoose(v); changed.push('clientBccEmails'); } }
      if (cCcAssignee) { const v = getCellString(row.getCell(cCcAssignee)); if (v) { patch.ccAssigneeOnClientStart = truthy(v); changed.push('ccAssigneeOnClientStart'); } }
      if (cCcManager) { const v = getCellString(row.getCell(cCcManager)); if (v) { patch.ccManagerOnClientStart = truthy(v); changed.push('ccManagerOnClientStart'); } }
      if (cStartSub) { const v = getCellString(row.getCell(cStartSub)); if (v) { patch.clientStartSubject = v; changed.push('clientStartSubject'); } }
      if (cStartBody) { const v = getCellString(row.getCell(cStartBody)); if (v) { patch.clientStartBody = v; changed.push('clientStartBody'); } }

      if (cSendComp) {
        const v = getCellString(row.getCell(cSendComp));
        if (v) { patch.sendClientCompletionMail = truthy(v); changed.push('sendClientCompletionMail'); }
      }
      if (cCompTo) { const v = getCellString(row.getCell(cCompTo)); if (v) { patch.completionToEmails = asEmailListLoose(v); changed.push('completionToEmails'); } }
      if (cCompCc) { const v = getCellString(row.getCell(cCompCc)); if (v) { patch.completionCcEmails = asEmailListLoose(v); changed.push('completionCcEmails'); } }
      if (cCompBcc) { const v = getCellString(row.getCell(cCompBcc)); if (v) { patch.completionBccEmails = asEmailListLoose(v); changed.push('completionBccEmails'); } }
      if (cCcAssigneeComp) { const v = getCellString(row.getCell(cCcAssigneeComp)); if (v) { patch.ccAssigneeOnCompletion = truthy(v); changed.push('ccAssigneeOnCompletion'); } }
      if (cCcManagerComp) { const v = getCellString(row.getCell(cCcManagerComp)); if (v) { patch.ccManagerOnCompletion = truthy(v); changed.push('ccManagerOnCompletion'); } }
      if (cCompSub) { const v = getCellString(row.getCell(cCompSub)); if (v) { patch.clientCompletionSubject = v; changed.push('clientCompletionSubject'); } }
      if (cCompBody) { const v = getCellString(row.getCell(cCompBody)); if (v) { patch.clientCompletionBody = v; changed.push('clientCompletionBody'); } }
    }

    if (!changed.length) {
      skippedCount++;
      continue;
    }

    // If dueDateYmd or triggerDaysBefore changed, recompute startDateYmd and patch calendar event
    const finalDueYmd = dueDateYmd || old.dueDateYmd;
    const finalTrigger = (triggerDaysBefore !== null && triggerDaysBefore !== undefined)
      ? triggerDaysBefore
      : (Number(old.triggerDaysBefore ?? 15));

    if (privileged && (dueDateYmd || triggerDaysBefore !== null)) {
      const startYmd = ymdIST(addDays(dateFromYmdIST(finalDueYmd), -finalTrigger));
      patch.startDateYmd = startYmd;
      patch.startDate = admin.firestore.Timestamp.fromDate(dateFromYmdIST(startYmd));
      changed.push('startDateYmd', 'startDate');

      // Patch calendar event
      try {
        const prefix = (old.status === 'COMPLETED') ? '[COMPLETED] ' : '';
        const summary = `${prefix}START: ${patch.title || old.title || 'Task'}`;
        const desc = `ClientId: ${old.clientId}\nStart: ${startYmd}\nDue: ${finalDueYmd}\n`;
        const eventId = old.calendarEventId || old.calendarStartEventId || null;

        await patchEvent({
          eventId,
          whenYmd: startYmd,
          summary,
          description: desc,
          colorId: (old.status === 'COMPLETED') ? '2' : null,
          window
        });

        if (old.calendarDueEventId) {
          await patchEvent({
            eventId: old.calendarDueEventId,
            whenYmd: finalDueYmd,
            summary: `${prefix}DUE: ${patch.title || old.title || 'Task'}`,
            description: desc,
            colorId: (old.status === 'COMPLETED') ? '2' : null,
            window
          });
        }
      } catch (e) {
        errors.push({ row: r, taskId, error: `Calendar patch failed (ignored): ${e.message || String(e)}` });
      }
    }

    patch.updatedAt = admin.firestore.FieldValue.serverTimestamp();

    await ref.update(patch);

    await auditLog({
      taskId,
      action: 'TASK_OFFLINE_UPDATE',
      actorUid: user.uid,
      actorEmail: user.email,
      details: { fields: changed }
    });

    updatedCount++;
  }

  return json(event, 200, {
    ok: true,
    updatedCount,
    skippedCount,
    errors: errors.slice(0, 200)
  });
});

       --- File Content End ---


    =� tasks_createone.js

       --- File Content Start ---

// netlify/functions/tasks_createone.js
const {
  withCors, json, db, admin,
  ymdIST, dateFromYmdIST, addDays, addInterval,
  getCalendarWindow,
  auditLog, asEmailList,
  createStartCalendarEvent, trySendStartMailImmediately
} = require('./_common');
const { requireUser } = require('./_auth');

async function findOrCreateClientByIdOrName({ clientId, clientName, clientEmail }) {
  if (clientId) {
    const cRef = db().collection('clients').doc(clientId);
    const cSnap = await cRef.get();
    if (!cSnap.exists) throw new Error('Client not found: ' + clientId);
    if (clientEmail && !cSnap.data().primaryEmail) await cRef.update({ primaryEmail: clientEmail });
    return { id: clientId, data: cSnap.data() };
  }
  if (!clientName) throw new Error('clientId or clientName required');

  const snap = await db().collection('clients').where('name', '==', clientName).limit(1).get();
  if (!snap.empty) {
    const id = snap.docs[0].id;
    const cRef = db().collection('clients').doc(id);
    const cSnap = await cRef.get();
    if (clientEmail && cSnap.exists && !cSnap.data().primaryEmail) await cRef.update({ primaryEmail: clientEmail });
    return { id, data: cSnap.data() };
  }

  const ref = db().collection('clients').doc();
  const newData = {
    name: clientName,
    primaryEmail: clientEmail || '',
    ccEmails: [],
    bccEmails: [],
    createdAt: admin.firestore.FieldValue.serverTimestamp()
  };
  await ref.set(newData);
  return { id: ref.id, data: newData };
}

async function findUserUidByEmail(email) {
  if (!email) return null;
  const e = String(email).trim().toLowerCase();
  let snap = await db().collection('users').where('emailLower', '==', e).limit(1).get();
  if (snap.empty) snap = await db().collection('users').where('email', '==', email).limit(1).get();
  if (snap.empty) return null;
  return snap.docs[0].id;
}

function normalizeRecurrence(x) {
  const r = String(x || 'AD_HOC').toUpperCase().trim();
  const allowed = ['AD_HOC','DAILY','WEEKLY','BIWEEKLY','MONTHLY','BIMONTHLY','QUARTERLY','HALF_YEARLY','YEARLY'];
  return allowed.includes(r) ? r : 'AD_HOC';
}

function normalizeCategory(x) {
  const raw = String(x || 'OTHER').trim();
  const u = raw.toUpperCase().replace(/\s+/g, '_');
  if (u === 'ITR' || u === 'INCOME_TAX' || u === 'INCOME-TAX' || raw.toLowerCase() === 'income tax') return 'INCOME_TAX';
  if (u === 'GST') return 'GST';
  if (u === 'TDS') return 'TDS';
  if (u === 'ROC') return 'ROC';
  if (u === 'ACCOUNTING') return 'ACCOUNTING';
  if (u === 'AUDIT') return 'AUDIT';
  return 'OTHER';
}

function normalizePriority(x) {
  const v = String(x || 'MEDIUM').trim().toUpperCase();
  if (v === 'HIGH' || v === 'LOW') return v;
  return 'MEDIUM';
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  // role normalization already done in _auth.js (WORKER->ASSOCIATE)
  const role = String(user.role || 'ASSOCIATE').toUpperCase().trim();

  const body = JSON.parse(event.body || '{}');

  const { id: clientId, data: clientData } = await findOrCreateClientByIdOrName({
    clientId: body.clientId || null,
    clientName: body.clientName || null,
    clientEmail: body.clientEmail || null,
  });

  const title = body.title || 'Untitled';
  const dueDateYmd = String(body.dueDateYmd || '').trim();
  if (!/^\d{4}-\d{2}-\d{2}$/.test(dueDateYmd)) {
    return json(event, 400, { ok:false, error:'dueDateYmd required (YYYY-MM-DD)' });
  }

  const recurrence = normalizeRecurrence(body.recurrence || 'AD_HOC');
  const generateCount = Math.max(1, parseInt(body.generateCount || '1', 10));
  const triggerDaysBefore = Math.max(0, parseInt(body.triggerDaysBefore ?? 15, 10));
  const category = normalizeCategory(body.category || 'OTHER');
  const type = String(body.type || 'FILING').trim();
  const priority = normalizePriority(body.priority || 'MEDIUM');

  // Assignment rules:
  // - ASSOCIATE: must assign to self
  // - MANAGER/PARTNER: can assign to anyone (if email exists), otherwise fallback to self
  let assignedToEmail = (body.assignedToEmail || user.email || '').trim();
  let assignedToUid = user.uid;
  if (role === 'ASSOCIATE') {
    assignedToEmail = user.email;
    assignedToUid = user.uid;
  } else {
    const uid = assignedToEmail ? (await findUserUidByEmail(assignedToEmail)) : null;
    assignedToUid = uid || user.uid;
    if (!uid) assignedToEmail = user.email;
  }

  // ===== Start mail control + templates + recipients =====
  const sendClientStartMail = (body.sendClientStartMail !== false); // default true
  const clientToEmails = asEmailList(body.clientToEmails || body.clientTo || body.clientEmail || null);
  const clientCcEmails = asEmailList(body.clientCcEmails || body.clientCc || null);
  const clientBccEmails = asEmailList(body.clientBccEmails || body.clientBcc || null);
  const ccAssigneeOnClientStart = body.ccAssigneeOnClientStart === true;
  const ccManagerOnClientStart = body.ccManagerOnClientStart === true;

  // Completion settings
  const sendClientCompletionMail = body.sendClientCompletionMail !== false;
  const clientStartSubject = String(body.clientStartSubject || '').trim();
  const clientStartBody = String(body.clientStartBody || '').trim();
  const clientCompletionSubject = String(body.clientCompletionSubject || '').trim();
  const clientCompletionBody = String(body.clientCompletionBody || '').trim();

  // Completion recipient overrides (new)
  const completionToEmails = asEmailList(body.completionToEmails || body.completionTo || null);
  const completionCcEmails = asEmailList(body.completionCcEmails || body.completionCc || null);
  const completionBccEmails = asEmailList(body.completionBccEmails || body.completionBcc || null);
  const ccAssigneeOnCompletion = body.ccAssigneeOnCompletion === true;
  const ccManagerOnCompletion = body.ccManagerOnCompletion === true;

  const isSeries = recurrence !== 'AD_HOC' && generateCount > 1;
  const seriesId = isSeries ? db().collection('taskSeries').doc().id : null;
  const seriesCreated = seriesId ? 1 : 0;

  const window = await getCalendarWindow();
  const todayYmd = ymdIST(new Date());

  let created = 0;

  for (let i = 0; i < generateCount; i++) {
    const dueDate = addInterval(dateFromYmdIST(dueDateYmd), recurrence, i);
    const dueYmd = ymdIST(dueDate);
    const startDate = addDays(dateFromYmdIST(dueYmd), -triggerDaysBefore);
    const startYmd = ymdIST(startDate);

    const ev = await createStartCalendarEvent({
      title, clientId, startDateYmd: startYmd, dueDateYmd: dueYmd, window
    });

    const taskObjForMail = {
      title,
      startDateYmd: startYmd,
      dueDateYmd: dueYmd,
      sendClientStartMail,
      clientStartSubject,
      clientStartBody,
      clientToEmails, clientCcEmails, clientBccEmails,
      ccAssigneeOnClientStart, ccManagerOnClientStart,
      assignedToEmail, assignedToUid
    };

    let mailResult = null;
    if (startYmd === todayYmd) {
      mailResult = await trySendStartMailImmediately({
        task: taskObjForMail,
        client: {
          name: clientData.name,
          primaryEmail: clientData.primaryEmail,
          ccEmails: clientData.ccEmails,
          bccEmails: clientData.bccEmails
        },
        window
      });
    }

    const tRef = db().collection('tasks').doc();
    await tRef.set({
      clientId,
      title,
      category,
      type,
      priority,
      recurrence,
      seriesId,
      occurrenceIndex: i + 1,
      occurrenceTotal: generateCount,
      dueDate: admin.firestore.Timestamp.fromDate(dateFromYmdIST(dueYmd)),
      dueDateYmd: dueYmd,
      triggerDaysBefore,
      startDate: admin.firestore.Timestamp.fromDate(dateFromYmdIST(startYmd)),
      startDateYmd: startYmd,
      assignedToUid,
      assignedToEmail,
      status: 'PENDING',
      statusNote: '',
      delayReason: null,
      delayNotes: '',
      snoozedUntilYmd: null,

      // Calendar single-event model
      calendarEventId: ev.calendarEventId,
      calendarHtmlLink: ev.calendarHtmlLink || null,
      calendarStartEventId: ev.calendarEventId,
      calendarDueEventId: null,

      // Start mail fields
      sendClientStartMail,
      clientToEmails,
      clientCcEmails,
      clientBccEmails,
      ccAssigneeOnClientStart,
      ccManagerOnClientStart,
      clientStartSubject,
      clientStartBody,
      clientStartMailSent: mailResult ? true : false,
      clientStartMailSentAt: mailResult?.clientStartMailSentAt || null,
      clientStartGmailThreadId: mailResult?.clientStartGmailThreadId || null,
      clientStartGmailId: mailResult?.clientStartGmailId || null,
      clientStartRfcMessageId: mailResult?.clientStartRfcMessageId || null,
      clientStartReferences: mailResult?.clientStartReferences || null,

      // Completion mail fields
      sendClientCompletionMail,
      clientCompletionSubject,
      clientCompletionBody,

      // Completion override recipients (new)
      completionToEmails,
      completionCcEmails,
      completionBccEmails,
      ccAssigneeOnCompletion,
      ccManagerOnCompletion,

      createdByUid: user.uid,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      completedRequestedAt: null,
      completedAt: null,
      attachments: []
    });

    await auditLog({
      taskId: tRef.id,
      action: 'TASK_CREATED',
      actorUid: user.uid,
      actorEmail: user.email,
      details: {
        source:'UI_CREATE',
        seriesId,
        occurrenceIndex: i+1,
        startDateYmd: startYmd,
        sentMailNow: !!mailResult
      }
    });

    created++;
  }

  return json(event, 200, { ok:true, created, seriesId, seriesCreated });
});

       --- File Content End ---


    =� tasks_delete.js

       --- File Content Start ---

// netlify/functions/tasks_delete.js
const { withCors, json, db, calendar, auditLog } = require('./_common');
const { requireUser } = require('./_auth');

async function deleteEvent(eventId) {
  if (!eventId) return;
  try {
    await calendar().events.delete({
      calendarId: 'primary',
      eventId,
      sendUpdates: 'none'
    });
  } catch {
    // ignore if already deleted / not found
  }
}

function roleOf(user) {
  let r = String(user?.role || 'ASSOCIATE').toUpperCase().trim();
  if (r === 'WORKER') r = 'ASSOCIATE'; // compat
  return r || 'ASSOCIATE';
}
function isPrivileged(role) {
  return role === 'PARTNER' || role === 'MANAGER';
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const role = roleOf(user);

  const body = JSON.parse(event.body || '{}');
  const taskId = String(body.taskId || '').trim();
  const applyToSeries = !!body.applyToSeries;

  if (!taskId) return json(event, 400, { ok:false, error:'taskId required' });

  const baseRef = db().collection('tasks').doc(taskId);
  const baseSnap = await baseRef.get();
  if (!baseSnap.exists) return json(event, 404, { ok:false, error:'Task not found' });
  const base = baseSnap.data();

  // Permission:
  // - PARTNER/MANAGER: can delete any task, series allowed
  // - ASSOCIATE: can delete only tasks assigned to them; series delete NOT allowed
  if (!isPrivileged(role)) {
    const isAssignee = base.assignedToUid === user.uid;
    if (!isAssignee) return json(event, 403, { ok:false, error:'Not allowed' });
    if (applyToSeries) return json(event, 403, { ok:false, error:'Associates cannot delete entire series' });
  }

  let targets = [];
  if (applyToSeries && base.seriesId) {
    const snap = await db().collection('tasks').where('seriesId', '==', base.seriesId).get();
    targets = snap.docs.map(d => ({ id: d.id, ref: d.ref, data: d.data() }));
  } else {
    targets = [{ id: taskId, ref: baseRef, data: base }];
  }

  // For associates, enforce again for every target
  if (!isPrivileged(role)) {
    const bad = targets.find(t => t.data.assignedToUid !== user.uid);
    if (bad) return json(event, 403, { ok:false, error:'Not allowed on some tasks' });
  }

  for (const t of targets) {
    const singleId = t.data.calendarEventId || t.data.calendarStartEventId || null;
    await deleteEvent(singleId);
    await deleteEvent(t.data.calendarDueEventId || null);

    await t.ref.delete();

    await auditLog({
      taskId: t.id,
      action: 'TASK_DELETED',
      actorUid: user.uid,
      actorEmail: user.email,
      details: { applyToSeries: !!applyToSeries, seriesId: base.seriesId || null, role }
    });
  }

  if (applyToSeries && base.seriesId) {
    try { await db().collection('taskSeries').doc(base.seriesId).delete(); } catch {}
  }

  return json(event, 200, { ok:true, deletedCount: targets.length });
});

       --- File Content End ---


    =� tasks_updatestatus.js

       --- File Content Start ---

// netlify/functions/tasks_updatestatus.js
const {
  withCors, json, db, admin,
  calendar, getCalendarWindow, calTimeRange,
  sendEmailReply, sendEmail,
  auditLog, renderTemplate, ymdToDmy, uniqEmails,
  resolveCompletionRecipients,
  resolveStartRecipients
} = require('./_common');
const { requireUser } = require('./_auth');

async function patchEvent({ eventId, whenYmd, summary, description, colorId = null, window }) {
  if (!eventId) return;
  const cal = calendar();
  const range = calTimeRange(whenYmd, window.startHH, window.endHH, window.timeZone);
  await cal.events.patch({
    calendarId: 'primary',
    eventId,
    sendUpdates: 'none',
    requestBody: {
      summary,
      description,
      ...range,
      ...(colorId ? { colorId } : {})
    }
  });
}

function roleOf(user) {
  const r = String(user?.role || 'ASSOCIATE').toUpperCase().trim();
  // Back-compat already handled, but keep safe
  return (r === 'WORKER') ? 'ASSOCIATE' : (r || 'ASSOCIATE');
}
function isPrivileged(role) {
  return role === 'PARTNER' || role === 'MANAGER';
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const role = roleOf(user);
  const body = JSON.parse(event.body || {});
  const { taskId, newStatus, statusNote, delayReason, delayNotes } = body;

  if (!taskId || !newStatus) return json(event, 400, { ok:false, error:'taskId,newStatus required' });

  const tRef = db().collection('tasks').doc(taskId);
  const tSnap = await tRef.get();
  if (!tSnap.exists) return json(event, 404, { ok:false, error:'Task not found' });
  const task = tSnap.data();

  const privileged = isPrivileged(role);
  const isAssignee = task.assignedToUid === user.uid;

  if (!privileged && !isAssignee) return json(event, 403, { ok:false, error:'Not allowed' });

  // Completion permission
  if (!privileged && String(newStatus).toUpperCase() === 'COMPLETED') {
    return json(event, 403, { ok:false, error:'Only partner/manager can mark COMPLETED' });
  }

  const updates = {
    status: newStatus,
    updatedAt: admin.firestore.FieldValue.serverTimestamp(),
  };
  if (typeof statusNote === 'string') updates.statusNote = statusNote;
  if (delayReason !== undefined) updates.delayReason = delayReason || null;
  if (typeof delayNotes === 'string') updates.delayNotes = delayNotes;
  if (newStatus === 'APPROVAL_PENDING') updates.completedRequestedAt = admin.firestore.FieldValue.serverTimestamp();
  if (newStatus === 'COMPLETED') updates.completedAt = admin.firestore.FieldValue.serverTimestamp();

  await tRef.update(updates);

  await auditLog({
    taskId,
    action: 'STATUS_CHANGE',
    actorUid: user.uid,
    actorEmail: user.email,
    details: { from: task.status, to: newStatus, statusNote: statusNote || '' }
  });

  // ===== On COMPLETED =====
  if (String(newStatus).toUpperCase() === 'COMPLETED') {
    const window = await getCalendarWindow();
    const desc =
      `ClientId: ${task.clientId}\n` +
      `Start: ${task.startDateYmd}\n` +
      `Due: ${task.dueDateYmd}\n`;

    // Patch calendar event(s)
    const eventId = task.calendarEventId || task.calendarStartEventId || null;
    try {
      if (eventId) {
        await patchEvent({
          eventId,
          whenYmd: task.startDateYmd,
          summary: `[COMPLETED] START: ${task.title}`,
          description: desc,
          colorId: '2',
          window
        });
      }
      if (task.calendarDueEventId) {
        await patchEvent({
          eventId: task.calendarDueEventId,
          whenYmd: task.dueDateYmd,
          summary: `[COMPLETED] DUE: ${task.title}`,
          description: desc,
          colorId: '2',
          window
        });
      }
    } catch (e) {
      console.warn('Calendar patch failed (ignored):', e.message || e);
    }

    // Respect per-task completion flag
    if (task.sendClientCompletionMail === false) {
      return json(event, 200, { ok:true, note:'Completed. Client completion email disabled for this task.' });
    }

    // Load client
    const cSnap = await db().collection('clients').doc(task.clientId).get();
    const client = cSnap.exists ? cSnap.data() : {};

    // Recipients: reply-all behaviour with overrides + internal trail
    const rec = await resolveCompletionRecipients({ client, task });
    if (!rec.to.length) {
      return json(event, 200, { ok:true, note:'Completed. No email recipient found for completion email.' });
    }

    const completedAtStr = new Date().toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' });
    const vars = {
      clientName: client.name || '',
      taskTitle: task.title || '',
      startDate: ymdToDmy(task.startDateYmd),
      dueDate: ymdToDmy(task.dueDateYmd),
      completedAt: completedAtStr,
      statusNote: (typeof updates.statusNote === 'string') ? updates.statusNote : (task.statusNote || ''),
    };

    const subject = renderTemplate(
      task.clientCompletionSubject || `Completed: {{taskTitle}}`,
      vars
    );

    const html = renderTemplate(
      task.clientCompletionBody || (
        `Dear {{clientName}},\n\n` +
        `We have completed: {{taskTitle}}\n` +
        `Due date: {{dueDate}}\n` +
        `Completed at: {{completedAt}}\n` +
        `Status note: {{statusNote}}\n\n` +
        `Regards,\n${process.env.MAIL_SIGNATURE || 'Compliance Team'}`
      ),
      vars
    );

    // Thread reply: reply in same thread if we have it
    const threadId = task.clientStartGmailThreadId || null;
    const inReplyTo = task.clientStartRfcMessageId || null;
    const references = task.clientStartReferences || inReplyTo || null;

    if (threadId) {
      await sendEmailReply({
        threadId,
        inReplyTo,
        references,
        to: rec.to,
        cc: rec.cc,
        bcc: rec.bcc,
        subject,
        html
      });
    } else {
      // fallback: send as new mail
      await sendEmail({
        to: rec.to,
        cc: rec.cc,
        bcc: rec.bcc,
        subject,
        html
      });
    }

    await auditLog({
      taskId,
      action: 'EMAIL_SENT',
      actorUid: null,
      actorEmail: null,
      details: {
        type:'CLIENT_COMPLETION',
        repliedToStartThread: !!threadId,
        to: rec.to,
        cc: rec.cc,
        bcc: rec.bcc
      }
    });
  }

  return json(event, 200, { ok:true });
});

       --- File Content End ---


    =� tasks_updatetask.js

       --- File Content Start ---

// netlify/functions/tasks_updatetask.js
const {
  withCors, json, db, admin,
  calendar, ymdIST, addDays, dateFromYmdIST,
  getCalendarWindow, calTimeRange,
  auditLog
} = require('./_common');
const { requireUser } = require('./_auth');

async function findUserUidByEmail(email) {
  if (!email) return null;
  const e = String(email).trim().toLowerCase();
  let snap = await db().collection('users').where('emailLower', '==', e).limit(1).get();
  if (snap.empty) snap = await db().collection('users').where('email', '==', email).limit(1).get();
  if (snap.empty) return null;
  return snap.docs[0].id;
}

function normalizeCategory(x) {
  const raw = String(x || 'OTHER').trim();
  const u = raw.toUpperCase().replace(/\s+/g, '_');
  if (u === 'ITR' || u === 'INCOME_TAX' || raw.toLowerCase() === 'income tax') return 'INCOME_TAX';
  if (u === 'GST') return 'GST';
  if (u === 'TDS') return 'TDS';
  if (u === 'ROC') return 'ROC';
  if (u === 'ACCOUNTING') return 'ACCOUNTING';
  if (u === 'AUDIT') return 'AUDIT';
  return 'OTHER';
}
function normalizePriority(x) {
  const v = String(x || 'MEDIUM').trim().toUpperCase();
  if (v === 'HIGH' || v === 'LOW') return v;
  return 'MEDIUM';
}
function asEmailListLoose(x) {
  if (Array.isArray(x)) return x.map(s => String(s).trim()).filter(Boolean);
  if (typeof x === 'string') return x.split(/[;,:]/).map(s => s.trim()).filter(Boolean);
  return [];
}

async function patchEvent({ eventId, whenYmd, summary, description, colorId=null, window }) {
  if (!eventId) return;
  const cal = calendar();
  const range = calTimeRange(whenYmd, window.startHH, window.endHH, window.timeZone);
  await cal.events.patch({
    calendarId: 'primary',
    eventId,
    sendUpdates: 'none',
    requestBody: {
      summary,
      description,
      ...range,
      ...(colorId ? { colorId } : {})
    }
  });
}
function completedPrefix(status) {
  return status === 'COMPLETED' ? '[COMPLETED] ' : '';
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const role = String(user.role || 'ASSOCIATE').toUpperCase().trim();
  const canEdit = (role === 'PARTNER' || role === 'MANAGER');
  if (!canEdit) return json(event, 403, { ok:false, error:'Partner/Manager only' });

  const body = JSON.parse(event.body || '{}');
  const taskId = String(body.taskId || '').trim();
  if (!taskId) return json(event, 400, { ok:false, error:'taskId required' });

  const baseRef = db().collection('tasks').doc(taskId);
  const baseSnap = await baseRef.get();
  if (!baseSnap.exists) return json(event, 404, { ok:false, error:'Task not found' });
  const base = baseSnap.data();

  const applyToSeries = !!body.applyToSeries && !!base.seriesId;

  // Editable fields
  const newTitle = String(body.title ?? base.title ?? '').trim() || base.title || 'Untitled';
  const newCategory = normalizeCategory(body.category ?? base.category ?? 'OTHER');
  const newType = String(body.type ?? base.type ?? 'FILING').trim();
  const newPriority = normalizePriority(body.priority ?? base.priority ?? 'MEDIUM');

  const newTrigger = body.triggerDaysBefore !== undefined
    ? Math.max(0, parseInt(body.triggerDaysBefore, 10))
    : (base.triggerDaysBefore ?? 15);

  const newAssignedEmail = String(body.assignedToEmail ?? base.assignedToEmail ?? '').trim();
  const newAssignedUid = newAssignedEmail
    ? ((await findUserUidByEmail(newAssignedEmail)) || base.assignedToUid)
    : base.assignedToUid;

  // Snooze
  const snoozedUntilYmd = (body.snoozedUntilYmd === null || body.snoozedUntilYmd === undefined)
    ? (base.snoozedUntilYmd || null)
    : String(body.snoozedUntilYmd || '').trim() || null;
  if (snoozedUntilYmd && !/^\d{4}-\d{2}-\d{2}$/.test(snoozedUntilYmd)) {
    return json(event, 400, { ok:false, error:'snoozedUntilYmd must be YYYY-MM-DD or null' });
  }

  // Due date change allowed ONLY for single occurrence
  const newDueDateYmd = (!applyToSeries && body.dueDateYmd)
    ? String(body.dueDateYmd).trim()
    : base.dueDateYmd;

  // ===== Start mail controls + recipients =====
  const sendClientStartMail =
    (body.sendClientStartMail === undefined)
      ? (base.sendClientStartMail !== false)
      : (body.sendClientStartMail !== false);

  const clientToEmails = asEmailListLoose(body.clientToEmails ?? base.clientToEmails ?? []);
  const clientCcEmails = asEmailListLoose(body.clientCcEmails ?? base.clientCcEmails ?? []);
  const clientBccEmails = asEmailListLoose(body.clientBccEmails ?? base.clientBccEmails ?? []);

  const ccAssigneeOnClientStart = body.ccAssigneeOnClientStart === true ? true :
    (body.ccAssigneeOnClientStart === false ? false : !!base.ccAssigneeOnClientStart);

  const ccManagerOnClientStart = body.ccManagerOnClientStart === true ? true :
    (body.ccManagerOnClientStart === false ? false : !!base.ccManagerOnClientStart);

  const newClientStartSubject = String(body.clientStartSubject ?? base.clientStartSubject ?? '');
  const newClientStartBody = String(body.clientStartBody ?? base.clientStartBody ?? '');

  // ===== Completion mail controls + overrides =====
  const sendClientCompletionMail =
    (body.sendClientCompletionMail === undefined)
      ? (base.sendClientCompletionMail !== false)
      : (body.sendClientCompletionMail !== false);

  const newClientCompletionSubject = String(body.clientCompletionSubject ?? base.clientCompletionSubject ?? '');
  const newClientCompletionBody = String(body.clientCompletionBody ?? base.clientCompletionBody ?? '');

  const completionToEmails = asEmailListLoose(body.completionToEmails ?? base.completionToEmails ?? []);
  const completionCcEmails = asEmailListLoose(body.completionCcEmails ?? base.completionCcEmails ?? []);
  const completionBccEmails = asEmailListLoose(body.completionBccEmails ?? base.completionBccEmails ?? []);

  const ccAssigneeOnCompletion = body.ccAssigneeOnCompletion === true ? true :
    (body.ccAssigneeOnCompletion === false ? false : !!base.ccAssigneeOnCompletion);

  const ccManagerOnCompletion = body.ccManagerOnCompletion === true ? true :
    (body.ccManagerOnCompletion === false ? false : !!base.ccManagerOnCompletion);

  // Targets
  let targets = [];
  if (applyToSeries) {
    const snap = await db().collection('tasks').where('seriesId', '==', base.seriesId).get();
    targets = snap.docs.map(d => ({ id: d.id, ref: d.ref, data: d.data() }));
  } else {
    targets = [{ id: taskId, ref: baseRef, data: base }];
  }

  const window = await getCalendarWindow();
  let updatedCount = 0;

  for (const t of targets) {
    const old = t.data;
    const dueYmd = (t.id === taskId) ? newDueDateYmd : old.dueDateYmd;

    if (!/^\d{4}-\d{2}-\d{2}$/.test(dueYmd)) {
      return json(event, 400, { ok:false, error:`Invalid dueDateYmd for task ${t.id}` });
    }

    const startYmd = ymdIST(addDays(dateFromYmdIST(dueYmd), -newTrigger));

    const updateDoc = {
      title: newTitle,
      category: newCategory,
      type: newType,
      priority: newPriority,

      triggerDaysBefore: newTrigger,

      assignedToEmail: newAssignedEmail || old.assignedToEmail || '',
      assignedToUid: newAssignedUid || old.assignedToUid || null,

      snoozedUntilYmd: snoozedUntilYmd || null,

      startDateYmd: startYmd,
      startDate: admin.firestore.Timestamp.fromDate(dateFromYmdIST(startYmd)),

      // Start mail
      sendClientStartMail,
      clientToEmails,
      clientCcEmails,
      clientBccEmails,
      ccAssigneeOnClientStart,
      ccManagerOnClientStart,
      clientStartSubject: newClientStartSubject,
      clientStartBody: newClientStartBody,

      // Completion mail + overrides
      sendClientCompletionMail,
      clientCompletionSubject: newClientCompletionSubject,
      clientCompletionBody: newClientCompletionBody,

      completionToEmails,
      completionCcEmails,
      completionBccEmails,
      ccAssigneeOnCompletion,
      ccManagerOnCompletion,

      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    };

    if (t.id === taskId) {
      updateDoc.dueDateYmd = dueYmd;
      updateDoc.dueDate = admin.firestore.Timestamp.fromDate(dateFromYmdIST(dueYmd));
    }

    await t.ref.update(updateDoc);

    // Patch calendar event
    const prefix = completedPrefix(old.status);
    const desc =
      `ClientId: ${old.clientId}\n` +
      `Start: ${startYmd}\n` +
      `Due: ${dueYmd}\n`;

    const eventId = old.calendarEventId || old.calendarStartEventId || null;
    await patchEvent({
      eventId,
      whenYmd: startYmd,
      summary: `${prefix}START: ${newTitle}`,
      description: desc,
      colorId: (old.status === 'COMPLETED') ? '2' : null,
      window
    });

    // Back-compat: patch old due event if exists
    if (old.calendarDueEventId) {
      await patchEvent({
        eventId: old.calendarDueEventId,
        whenYmd: dueYmd,
        summary: `${prefix}DUE: ${newTitle}`,
        description: desc,
        colorId: (old.status === 'COMPLETED') ? '2' : null,
        window
      });
    }

    await auditLog({
      taskId: t.id,
      action: 'TASK_EDITED',
      actorUid: user.uid,
      actorEmail: user.email,
      details: { applyToSeries, baseTaskId: taskId }
    });

    updatedCount++;
  }

  return json(event, 200, {
    ok:true,
    updatedCount,
    applyToSeries,
    seriesId: base.seriesId || null
  });
});

       --- File Content End ---


    =� tasks_uploadattachment.js

       --- File Content Start ---

// netlify/functions/tasks_uploadattachment.js
const Busboy = require('busboy');
const { withCors, json, db, admin, drive, auditLog } = require('./_common');
const { requireUser } = require('./_auth');

function roleOf(user) {
  let r = String(user?.role || 'ASSOCIATE').toUpperCase().trim();
  if (r === 'WORKER') r = 'ASSOCIATE'; // compat
  return r || 'ASSOCIATE';
}
function isPrivileged(role) {
  return role === 'PARTNER' || role === 'MANAGER';
}

async function ensureRootFolder() {
  const d = drive();
  const name = process.env.DRIVE_ROOT_FOLDER_NAME || 'ComplianceManagement';
  const res = await d.files.list({
    q: `mimeType='application/vnd.google-apps.folder' and name='${name}' and trashed=false`,
    fields: 'files(id,name)',
    spaces: 'drive'
  });
  if (res.data.files && res.data.files.length) return res.data.files[0].id;

  const created = await d.files.create({
    requestBody: { name, mimeType: 'application/vnd.google-apps.folder' },
    fields: 'id'
  });
  return created.data.id;
}

async function ensureClientFolder(clientId) {
  const cRef = db().collection('clients').doc(clientId);
  const cSnap = await cRef.get();
  const client = cSnap.data() || {};

  if (client.driveFolderId) return client.driveFolderId;

  const rootId = await ensureRootFolder();
  const folderName = `${client.name || 'Client'}_${clientId}`;
  const d = drive();

  const created = await d.files.create({
    requestBody: {
      name: folderName,
      mimeType: 'application/vnd.google-apps.folder',
      parents: [rootId]
    },
    fields: 'id'
  });

  await cRef.update({ driveFolderId: created.data.id });
  return created.data.id;
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const role = roleOf(user);

  const busboy = Busboy({ headers: event.headers });
  let taskId = null;
  let attachmentType = 'OTHER';
  let fileBuffer = Buffer.alloc(0);
  let fileName = 'file';
  let mimeType = 'application/octet-stream';

  busboy.on('field', (name, val) => {
    if (name === 'taskId') taskId = String(val || '').trim();
    if (name === 'type') attachmentType = String(val || 'OTHER').toUpperCase().trim();
  });

  busboy.on('file', (name, file, info) => {
    fileName = info.filename || 'file';
    mimeType = info.mimeType || 'application/octet-stream';
    file.on('data', (d) => { fileBuffer = Buffer.concat([fileBuffer, d]); });
  });

  const done = new Promise((resolve, reject) => {
    busboy.on('finish', resolve);
    busboy.on('error', reject);
  });

  const bodyBuf = event.isBase64Encoded ? Buffer.from(event.body, 'base64') : Buffer.from(event.body || '');
  busboy.end(bodyBuf);
  await done;

  if (!taskId) return json(event, 400, { ok:false, error:'taskId required' });
  if (!fileBuffer.length) return json(event, 400, { ok:false, error:'file missing' });

  const tRef = db().collection('tasks').doc(taskId);
  const tSnap = await tRef.get();
  if (!tSnap.exists) return json(event, 404, { ok:false, error:'Task not found' });
  const task = tSnap.data();

  const privileged = isPrivileged(role);
  const isAssignee = task.assignedToUid === user.uid;

  if (!privileged && !isAssignee) {
    return json(event, 403, { ok:false, error:'Not allowed' });
  }

  const folderId = await ensureClientFolder(task.clientId);

  const created = await drive().files.create({
    requestBody: { name: fileName, parents: [folderId] },
    media: { mimeType, body: Buffer.from(fileBuffer) },
    fields: 'id, webViewLink'
  });

  const attachment = {
    type: attachmentType,
    fileName,
    mimeType,
    driveFileId: created.data.id,
    driveWebViewLink: created.data.webViewLink,
    uploadedByUid: user.uid,
    uploadedAt: admin.firestore.FieldValue.serverTimestamp()
  };

  await tRef.update({
    attachments: admin.firestore.FieldValue.arrayUnion(attachment),
    updatedAt: admin.firestore.FieldValue.serverTimestamp()
  });

  await auditLog({
    taskId,
    action: 'ATTACHMENT_UPLOAD',
    actorUid: user.uid,
    actorEmail: user.email,
    details: { fileName, type: attachmentType }
  });

  return json(event, 200, { ok:true, attachment });
});

       --- File Content End ---


    =� users_list.js

       --- File Content Start ---

// netlify/functions/users_list.js
const { withCors, json, db } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');

function normalizeRole(role) {
  const r = String(role || '').toUpperCase().trim();
  if (r === 'WORKER') return 'ASSOCIATE';
  return r || 'ASSOCIATE';
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;

  const { user } = authRes;
  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const body = event.body ? JSON.parse(event.body) : {};
  const onlyActive = body.onlyActive === true;

  let q = db().collection('users');
  if (onlyActive) q = q.where('active', '==', true);

  const snap = await q.orderBy('email', 'asc').limit(500).get();

  const users = snap.docs.map(d => {
    const u = d.data() || {};
    return {
      uid: d.id,
      ...u,
      role: normalizeRole(u.role)
    };
  });

  return json(event, 200, { ok:true, users });
});

       --- File Content End ---


    =� users_setDisplayName.js

       --- File Content Start ---

// netlify/functions/users_setdisplayname.js
const { withCors, json, db, admin } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');

function normName(s) {
  return String(s || '').trim().replace(/\s+/g, ' ');
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const body = JSON.parse(event.body || '{}');
  const uid = String(body.uid || '').trim();
  const displayName = normName(body.displayName);

  if (!uid) return json(event, 400, { ok:false, error:'uid required' });
  if (!displayName) return json(event, 400, { ok:false, error:'displayName required' });
  if (displayName.length > 60) return json(event, 400, { ok:false, error:'displayName too long (max 60)' });

  await db().collection('users').doc(uid).set({
    displayName,
    displayNameLower: displayName.toLowerCase(),
    updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    updatedBy: user.email
  }, { merge: true });

  return json(event, 200, { ok:true, uid, displayName });
});

       --- File Content End ---


    =� users_setManager.js

       --- File Content Start ---

// netlify/functions/users_setManager.js
const { withCors, json, db, admin } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');

/**
 * Allows saving ANY managerEmail (even if manager user not created yet)
 * - If managerEmail exists in users (emailLower match), also store managerUid (only if role is PARTNER/MANAGER)
 * - If managerEmail is empty => clear managerEmail + managerUid
 */

async function findUserByEmailLower(email) {
  const e = String(email || '').trim().toLowerCase();
  if (!e) return null;
  const snap = await db().collection('users').where('emailLower', '==', e).limit(1).get();
  if (snap.empty) return null;
  return { uid: snap.docs[0].id, ...snap.docs[0].data() };
}

async function findUserByUid(uid) {
  const s = await db().collection('users').doc(uid).get();
  if (!s.exists) return null;
  return { uid: s.id, ...s.data() };
}

function normalizeRole(role) {
  const r = String(role || '').toUpperCase().trim();
  if (r === 'WORKER') return 'ASSOCIATE';
  return r || 'ASSOCIATE';
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;

  const { user } = authRes;
  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const body = JSON.parse(event.body || '{}');
  const targetUid = body.uid || null;
  const targetEmail = body.email || null;
  const managerEmailRaw = String(body.managerEmail || '').trim();

  if (!targetUid && !targetEmail) {
    return json(event, 400, { ok:false, error:'uid or email required' });
  }

  const target = targetUid ? await findUserByUid(targetUid) : await findUserByEmailLower(targetEmail);
  if (!target) return json(event, 404, { ok:false, error:'Target user not found' });

  // Clear manager mapping
  if (!managerEmailRaw) {
    await db().collection('users').doc(target.uid).set({
      managerEmail: null,
      managerUid: null,
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedBy: user.email
    }, { merge: true });

    return json(event, 200, { ok:true, uid: target.uid, managerEmail: null, managerUid: null });
  }

  const managerEmail = managerEmailRaw;
  const looksLikeEmail = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(managerEmail);
  if (!looksLikeEmail) {
    return json(event, 400, { ok:false, error:'managerEmail is not a valid email address' });
  }

  // Best-effort: resolve managerUid if manager is already in users
  let managerUid = null;
  let managerRole = null;

  const mgr = await findUserByEmailLower(managerEmail);
  if (mgr) {
    managerUid = mgr.uid;
    managerRole = normalizeRole(mgr.role);
    // Only allow PARTNER/MANAGER to be linked as managerUid
    if (!['PARTNER','MANAGER'].includes(managerRole)) {
      managerUid = null;
    }
  }

  await db().collection('users').doc(target.uid).set({
    managerEmail,
    managerUid: managerUid || null,
    updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    updatedBy: user.email
  }, { merge: true });

  return json(event, 200, {
    ok:true,
    uid: target.uid,
    managerEmail,
    managerUid: managerUid || null,
    note: mgr ? 'manager resolved' : 'manager email saved (user not found yet)'
  });
});

       --- File Content End ---


    =� users_setrole.js

       --- File Content Start ---

// netlify/functions/users_setrole.js
const { withCors, json, db, admin } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');

const ROLES = new Set(['PARTNER','MANAGER','ASSOCIATE','WORKER']); // keep WORKER for compat/migration

async function findUserUidByEmail(email) {
  if (!email) return null;
  const e = String(email).trim().toLowerCase();
  const snap = await db().collection('users').where('emailLower', '==', e).limit(1).get();
  if (snap.empty) return null;
  return snap.docs[0].id;
}

function normalizeRole(role) {
  const r = String(role || '').toUpperCase().trim();
  if (r === 'WORKER') return 'ASSOCIATE'; // enforce rename but accept input
  return r;
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;

  const { user } = authRes;
  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const body = JSON.parse(event.body || '{}');
  const uid = body.uid || null;
  const email = body.email || null;

  const roleIn = body.role || '';
  const role = normalizeRole(roleIn);
  const active = body.active !== false;

  if (!uid && !email) return json(event, 400, { ok:false, error:'uid or email required' });
  if (!ROLES.has(String(roleIn || '').toUpperCase().trim()) && String(roleIn || '').toUpperCase().trim() !== 'WORKER') {
    return json(event, 400, { ok:false, error:'role must be PARTNER / MANAGER / ASSOCIATE' });
  }
  if (!['PARTNER','MANAGER','ASSOCIATE'].includes(role)) {
    return json(event, 400, { ok:false, error:'role must be PARTNER / MANAGER / ASSOCIATE' });
  }

  const targetUid = uid || await findUserUidByEmail(email);
  if (!targetUid) return json(event, 404, { ok:false, error:'User not found' });

  await db().collection('users').doc(targetUid).set({
    role,
    active,
    updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    updatedBy: user.email
  }, { merge: true });

  return json(event, 200, { ok:true, uid: targetUid, role, active });
});

       --- File Content End ---

