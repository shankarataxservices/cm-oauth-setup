--- Contents of: /home/ubuntu/cm-oauth-setup/compliance-backend/netlify/functions ---

    =� _auth.js

       --- File Content Start ---

const { auth, db, json } = require('./_common');

async function requireUser(event) {
  const h = event.headers.authorization || event.headers.Authorization || '';
  const token = h.startsWith('Bearer ') ? h.slice(7) : null;
  if (!token) return { error: json(event, 401, { ok:false, error:'Missing Bearer token' }) };

  const decoded = await auth().verifyIdToken(token);
  const uSnap = await db().collection('users').doc(decoded.uid).get();
  const u = uSnap.exists ? uSnap.data() : null;

  return { user: { uid: decoded.uid, email: decoded.email, role: u?.role || 'WORKER' } };
}

function requirePartner(event, user) {
  if (user.role !== 'PARTNER') return { error: json(event, 403, { ok:false, error:'Partner only' }) };
  return { ok:true };
}

function requireCron(event) {
  const s = event.headers['x-cron-secret'] || event.headers['X-Cron-Secret'];
  if (!s || s !== process.env.CRON_SECRET) return { error: json(event, 401, { ok:false, error:'Bad cron secret' }) };
  return { ok:true };
}

module.exports = { requireUser, requirePartner, requireCron };

       --- File Content End ---


    =� _common.js

       --- File Content Start ---

const admin = require('firebase-admin');
const { google } = require('googleapis');
const { Readable } = require('stream');

let inited = false;

function init() {
  if (inited) return;
  const sa = JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT);
  admin.initializeApp({ credential: admin.credential.cert(sa) });
  inited = true;
}

function db() { init(); return admin.firestore(); }
function auth() { init(); return admin.auth(); }

function oauthClient() {
  const o = new google.auth.OAuth2(process.env.GOOGLE_CLIENT_ID, process.env.GOOGLE_CLIENT_SECRET);
  o.setCredentials({ refresh_token: process.env.GOOGLE_REFRESH_TOKEN });
  return o;
}

function calendar() { return google.calendar({ version: 'v3', auth: oauthClient() }); }
function gmail() { return google.gmail({ version: 'v1', auth: oauthClient() }); }
function drive() { return google.drive({ version: 'v3', auth: oauthClient() }); }

/** CORS headers ALWAYS */
function corsHeaders(event) {
  const origin = event?.headers?.origin || event?.headers?.Origin || '*';
  return {
    'Access-Control-Allow-Origin': origin,
    'Vary': 'Origin',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization, x-cron-secret',
    'Access-Control-Allow-Methods': 'GET,POST,OPTIONS',
    'Access-Control-Max-Age': '86400',
  };
}

function json(event, statusCode, body) {
  return {
    statusCode,
    headers: { ...corsHeaders(event), 'Content-Type': 'application/json' },
    body: JSON.stringify(body),
  };
}

/** Wrapper: OPTIONS + try/catch + always CORS */
function withCors(handler) {
  return async (event, context) => {
    if (event.httpMethod === 'OPTIONS') {
      return { statusCode: 204, headers: corsHeaders(event), body: '' };
    }
    try {
      const res = await handler(event, context);
      res.headers = { ...corsHeaders(event), ...(res.headers || {}) };
      return res;
    } catch (e) {
      console.error('Function crashed:', e);
      return json(event, 500, { ok:false, error: e.message || String(e) });
    }
  };
}

// ===== Date helpers =====
function ymd(d) {
  const x = new Date(d);
  x.setHours(0,0,0,0);
  const yyyy = x.getFullYear();
  const mm = String(x.getMonth()+1).padStart(2,'0');
  const dd = String(x.getDate()).padStart(2,'0');
  return `${yyyy}-${mm}-${dd}`;
}

function ymdToDmy(ymdStr) {
  if (!ymdStr) return '';
  const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(String(ymdStr).trim());
  if (!m) return '';
  return `${m[3]}-${m[2]}-${m[1]}`;
}

function dmyToYmd(dmyStr) {
  const s = String(dmyStr || '').trim();
  const m = /^(\d{2})-(\d{2})-(\d{4})$/.exec(s);
  if (!m) throw new Error(`Invalid date format "${s}". Expected DD-MM-YYYY`);
  const dd = m[1], mm = m[2], yyyy = m[3];
  // Validate quickly
  const iso = `${yyyy}-${mm}-${dd}`;
  const dt = new Date(`${iso}T00:00:00`);
  if (Number.isNaN(dt.getTime())) throw new Error(`Invalid date: ${s}`);
  // Ensure it round-trips
  const check = ymd(dt);
  if (check !== iso) throw new Error(`Invalid date: ${s}`);
  return iso;
}

function addDays(date, days) {
  const d = new Date(date);
  d.setDate(d.getDate() + days);
  return d;
}

function addInterval(baseDate, recurrence, i) {
  const d = new Date(baseDate);
  if (i === 0) return d;

  const r = String(recurrence || 'AD_HOC').toUpperCase();

  if (r === 'DAILY') d.setDate(d.getDate() + i);
  else if (r === 'WEEKLY') d.setDate(d.getDate() + i * 7);
  else if (r === 'BIWEEKLY') d.setDate(d.getDate() + i * 14);
  else if (r === 'MONTHLY') d.setMonth(d.getMonth() + i);
  else if (r === 'BIMONTHLY') d.setMonth(d.getMonth() + i * 2);
  else if (r === 'QUARTERLY') d.setMonth(d.getMonth() + i * 3);
  else if (r === 'HALF_YEARLY') d.setMonth(d.getMonth() + i * 6);
  else if (r === 'YEARLY') d.setFullYear(d.getFullYear() + i);
  else d.setDate(d.getDate() + i);

  return d;
}

// ===== Calendar timed event helper (10–12 IST) =====
const IST_TZ = 'Asia/Kolkata';
function calTimeRange(ymdStr, startHH=10, endHH=12) {
  return {
    start: { dateTime: `${ymdStr}T${String(startHH).padStart(2,'0')}:00:00`, timeZone: IST_TZ },
    end: { dateTime: `${ymdStr}T${String(endHH).padStart(2,'0')}:00:00`, timeZone: IST_TZ },
  };
}

async function auditLog({ taskId, action, actorUid, actorEmail, details }) {
  await db().collection('auditLogs').add({
    taskId: taskId || null,
    action,
    actorUid: actorUid || null,
    actorEmail: actorEmail || null,
    timestamp: admin.firestore.FieldValue.serverTimestamp(),
    details: details || {}
  });
}

function buildRawEmail({ from, to, cc = [], bcc = [], subject, html }) {
  const safeFrom = from || process.env.BOT_FROM || process.env.BOT_EMAIL || '';
  if (!safeFrom) throw new Error('BOT_FROM or BOT_EMAIL env var is missing');

  const lines = [
    `From: ${safeFrom}`,
    `To: ${to.join(', ')}`,
    cc.length ? `Cc: ${cc.join(', ')}` : null,
    bcc.length ? `Bcc: ${bcc.join(', ')}` : null,
    `Subject: ${subject}`,
    `Date: ${new Date().toUTCString()}`,
    'MIME-Version: 1.0',
    'Content-Type: text/html; charset="UTF-8"',
    '',
    html || ''
  ];

  const msg = lines.filter(x => x !== null).join('\r\n');

  return Buffer.from(msg)
    .toString('base64')
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=+$/, '');
}

async function sendEmail({ to, cc = [], bcc = [], subject, html }) {
  if (!to?.length) return;
  const g = gmail();
  const raw = buildRawEmail({ from: process.env.BOT_FROM, to, cc, bcc, subject, html });
  await g.users.messages.send({ userId: 'me', requestBody: { raw } });
}

async function driveUpload({ folderId, filename, mimeType, buffer }) {
  const d = drive();
  const res = await d.files.create({
    requestBody: { name: filename, parents: [folderId] },
    media: { mimeType, body: Readable.from(buffer) },
    fields: 'id, webViewLink, size, mimeType, name'
  });
  return res.data;
}

module.exports = {
  admin, db, auth, calendar, gmail, drive,
  withCors, json,
  ymd, ymdToDmy, dmyToYmd, addDays, addInterval,
  IST_TZ, calTimeRange,
  auditLog, sendEmail, driveUpload
};

       --- File Content End ---


    =� clients_create.js

       --- File Content Start ---

const { withCors, json, db, admin, auditLog } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');

function asEmailList(x) {
  if (Array.isArray(x)) return x.map(s => String(s).trim()).filter(Boolean);
  if (typeof x === 'string') return x.split(/[;,]/).map(s => s.trim()).filter(Boolean);
  return [];
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const body = JSON.parse(event.body || '{}');

  const ref = db().collection('clients').doc();
  await ref.set({
    name: body.name || '',
    pan: body.pan || '',
    gstin: body.gstin || '',
    cin: body.cin || '',
    assessmentYear: body.assessmentYear || body.ay || '',
    engagementType: body.engagementType || body.eng || '',
    primaryEmail: body.primaryEmail || body.email || '',
    ccEmails: asEmailList(body.ccEmails || body.cc),
    bccEmails: asEmailList(body.bccEmails || body.bcc),
    driveFolderId: null,
    createdAt: admin.firestore.FieldValue.serverTimestamp()
  });

  await auditLog({ action:'CLIENT_CREATED', actorUid:user.uid, actorEmail:user.email, details:{ clientId: ref.id } });
  return json(event, 200, { ok:true, clientId: ref.id });
});

       --- File Content End ---


    =� exports_clientHistoryXlsx.js

       --- File Content Start ---

const { withCors, json, db, ymdToDmy } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');
const ExcelJS = require('exceljs');

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const { clientId, fromYmd, toYmd } = JSON.parse(event.body || '{}');
  if (!clientId || !fromYmd || !toYmd) return json(event, 400, { ok:false, error:'clientId,fromYmd,toYmd required' });

  const clientSnap = await db().collection('clients').doc(clientId).get();
  if (!clientSnap.exists) return json(event, 404, { ok:false, error:'Client not found' });
  const client = clientSnap.data();

  const tasksSnap = await db().collection('tasks')
    .where('clientId', '==', clientId)
    .where('dueDateYmd', '>=', fromYmd)
    .where('dueDateYmd', '<=', toYmd)
    .get();

  const wb = new ExcelJS.Workbook();

  // FIX: do NOT use "History"
  const ws = wb.addWorksheet('ClientHistory');

  ws.addRow([
    'Client',
    'Title',
    'Category',
    'Type',
    'Recurrence',
    'SeriesId',
    'Occur',
    'Start (DD-MM-YYYY)',
    'Due (DD-MM-YYYY)',
    'Status',
    'Status Note',
    'Client Start Mail Sent'
  ]);

  for (const tDoc of tasksSnap.docs) {
    const t = tDoc.data();
    ws.addRow([
      client.name,
      t.title,
      t.category,
      t.type,
      t.recurrence || '',
      t.seriesId || '',
      t.seriesId ? `${t.occurrenceIndex || ''}/${t.occurrenceTotal || ''}` : '',
      ymdToDmy(t.startDateYmd),
      ymdToDmy(t.dueDateYmd),
      t.status,
      t.statusNote || '',
      t.clientStartMailSent ? 'YES' : 'NO'
    ]);
  }

  const buf = await wb.xlsx.writeBuffer();
  return json(event, 200, {
    ok: true,
    fileName: `${client.name}_history_${ymdToDmy(fromYmd)}_to_${ymdToDmy(toYmd)}.xlsx`,
    base64: Buffer.from(buf).toString('base64')
  });
});

       --- File Content End ---


    =� jobs_daily.js

       --- File Content Start ---

const { withCors, json } = require('./_common');

// Kept only to avoid confusion / older calls.
// Use jobs_daily5am for actual scheduling.
exports.handler = withCors(async (event) => {
  return json(event, 200, { ok:true, note:'Use /.netlify/functions/jobs_daily5am (this one is a no-op alias).' });
});

       --- File Content End ---


    =� jobs_daily5am.js

       --- File Content Start ---

const { withCors, json, db, ymd, addDays, sendEmail, auditLog, admin } = require('./_common');
const { requireCron } = require('./_auth');

function uniq(arr) { return [...new Set((arr||[]).map(x=>String(x).trim()).filter(Boolean))]; }

function renderTemplate(str, vars) {
  return String(str || '')
    .replaceAll('{{clientName}}', vars.clientName || '')
    .replaceAll('{{taskTitle}}', vars.taskTitle || '')
    .replaceAll('{{startDate}}', vars.startDate || '')
    .replaceAll('{{dueDate}}', vars.dueDate || '');
}

function buildDigestHtml(tasks) {
  const lines = tasks
    .sort((a,b)=>String(a.dueDateYmd||'').localeCompare(String(b.dueDateYmd||'')))
    .map(t => `<li><b>${t.title}</b> — Client: ${t.clientId} — Start ${t.startDateYmd} — Due ${t.dueDateYmd} — <b>${t.status}</b></li>`)
    .join('');
  return `<p>Tasks requiring action:</p><ul>${lines || '<li>None</li>'}</ul>`;
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const cron = requireCron(event);
  if (cron.error) return cron.error;

  const body = event.body ? JSON.parse(event.body) : {};
  const force = !!body.force;

  const todayYmd = ymd(new Date());

  // settings are only for INTERNAL daily digest
  const settingsRef = db().collection('settings').doc('notifications');
  const settingsSnap = await settingsRef.get();
  const settings = settingsSnap.exists ? settingsSnap.data() : {
    dailyInternalEmails: [],
    dailyWindowDays: 30,
    sendDailyToAssignees: true,
    lastDailyRunYmd: null
  };

  if (!force && settings.lastDailyRunYmd === todayYmd) {
    return json(event, 200, { ok:true, skipped:true, reason:'Already ran today' });
  }

  const activeStatuses = ['PENDING','IN_PROGRESS','CLIENT_PENDING','APPROVAL_PENDING'];

  // ========= PART 1: CLIENT START MAILS (send only on start date, once) =========
  // Query minimal fields to reduce index requirements:
  const startSnap = await db().collection('tasks')
    .where('startDateYmd', '==', todayYmd)
    .where('clientStartMailSent', '==', false)
    .get();

  let clientMailsSent = 0;

  for (const doc of startSnap.docs) {
    const t = doc.data();
    if (!activeStatuses.includes(t.status)) continue;

    // If no template in CSV, don't mail.
    if (!t.clientStartSubject && !t.clientStartBody) continue;

    const cSnap = await db().collection('clients').doc(t.clientId).get();
    const client = cSnap.exists ? cSnap.data() : {};
    if (!client.primaryEmail) continue;

    const vars = {
      clientName: client.name || '',
      taskTitle: t.title || '',
      startDate: t.startDateYmd || '',
      dueDate: t.dueDateYmd || ''
    };

    const subject = renderTemplate(t.clientStartSubject || `We have started work on {{taskTitle}}`, vars);
    const html = renderTemplate(
      t.clientStartBody || `Dear {{clientName}},<br><br>We have started working on <b>{{taskTitle}}</b>.<br>Due date: <b>{{dueDate}}</b>.<br><br>Regards,<br>Compliance Team`,
      vars
    );

    await sendEmail({
      to: [client.primaryEmail],
      cc: client.ccEmails || [],
      bcc: client.bccEmails || [],
      subject,
      html
    });

    await doc.ref.update({
      clientStartMailSent: true,
      clientStartMailSentAt: admin.firestore.FieldValue.serverTimestamp()
    });

    await auditLog({ taskId: doc.id, action:'EMAIL_SENT', actorUid:null, actorEmail:null, details:{ type:'CLIENT_START' } });
    clientMailsSent++;
  }

  // ========= PART 2: INTERNAL DAILY DIGEST (optional) =========
  const windowDays = Number(settings.dailyWindowDays || 30);
  const endYmd = ymd(addDays(new Date(), windowDays));

  const dueSoonSnap = await db().collection('tasks')
    .where('status', 'in', activeStatuses)
    .where('dueDateYmd', '>=', todayYmd)
    .where('dueDateYmd', '<=', endYmd)
    .get();

  const overdueSnap = await db().collection('tasks')
    .where('status', 'in', activeStatuses)
    .where('dueDateYmd', '<', todayYmd)
    .get();

  const digestTasks = [
    ...dueSoonSnap.docs.map(d => ({ id:d.id, ...d.data() })),
    ...overdueSnap.docs.map(d => ({ id:d.id, ...d.data() })),
  ];

  // Group by assignee
  const byAssignee = new Map();
  for (const t of digestTasks) {
    const key = t.assignedToEmail || '';
    if (!key) continue;
    if (!byAssignee.has(key)) byAssignee.set(key, []);
    byAssignee.get(key).push(t);
  }

  const internalExtra = uniq(settings.dailyInternalEmails || []);

  if (settings.sendDailyToAssignees !== false) {
    for (const [email, list] of byAssignee.entries()) {
      await sendEmail({
        to: [email],
        subject: `Daily Task Digest (${todayYmd})`,
        html: buildDigestHtml(list)
      });
    }
  }

  if (internalExtra.length) {
    await sendEmail({
      to: internalExtra,
      subject: `Firm Daily Digest (${todayYmd})`,
      html: buildDigestHtml(digestTasks)
    });
  }

  await settingsRef.set({ lastDailyRunYmd: todayYmd }, { merge: true });

  return json(event, 200, {
    ok:true,
    todayYmd,
    clientMailsSent,
    digestCount: digestTasks.length
  });
});

       --- File Content End ---


    =� jobs_monthlysummary.js

       --- File Content Start ---

const { withCors, json, db, sendEmail } = require('./_common');
const { requireCron } = require('./_auth');

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const cron = requireCron(event);
  if (cron.error) return cron.error;

  // Keeping this as-is, but it will run ONLY if you schedule it.
  // If you don't want monthly mails, simply don't create a cron workflow for this.
  return json(event, 200, { ok:true, note:'Monthly summary not enabled in this setup (no-op).' });
});

       --- File Content End ---


    =� manifest.json

       --- File Content Start ---

{"functions":[{"bundler":"zisi","buildData":{"runtimeAPIVersion":1},"mainFile":"/home/ubuntu/cm-oauth-setup/compliance-backend/.netlify/functions/_auth.js","name":"_auth","priority":10,"path":"/home/ubuntu/cm-oauth-setup/compliance-backend/.netlify/functions/_auth.zip","runtime":"js"},{"bundler":"zisi","buildData":{},"mainFile":"/home/ubuntu/cm-oauth-setup/compliance-backend/.netlify/functions/_common.js","name":"_common","priority":10,"path":"/home/ubuntu/cm-oauth-setup/compliance-backend/.netlify/functions/_common.zip","runtime":"js"},{"bundler":"zisi","buildData":{"runtimeAPIVersion":1},"mainFile":"/home/ubuntu/cm-oauth-setup/compliance-backend/.netlify/functions/clients_create.js","name":"clients_create","priority":10,"path":"/home/ubuntu/cm-oauth-setup/compliance-backend/.netlify/functions/clients_create.zip","runtime":"js"},{"bundler":"zisi","buildData":{"runtimeAPIVersion":1},"mainFile":"/home/ubuntu/cm-oauth-setup/compliance-backend/.netlify/functions/exports_clientHistoryXlsx.js","name":"exports_clientHistoryXlsx","priority":10,"path":"/home/ubuntu/cm-oauth-setup/compliance-backend/.netlify/functions/exports_clientHistoryXlsx.zip","runtime":"js"},{"bundler":"zisi","buildData":{"runtimeAPIVersion":1},"mainFile":"/home/ubuntu/cm-oauth-setup/compliance-backend/.netlify/functions/jobs_daily.js","name":"jobs_daily","priority":10,"path":"/home/ubuntu/cm-oauth-setup/compliance-backend/.netlify/functions/jobs_daily.zip","runtime":"js"},{"bundler":"zisi","buildData":{"runtimeAPIVersion":1},"mainFile":"/home/ubuntu/cm-oauth-setup/compliance-backend/.netlify/functions/jobs_daily5am.js","name":"jobs_daily5am","priority":10,"path":"/home/ubuntu/cm-oauth-setup/compliance-backend/.netlify/functions/jobs_daily5am.zip","runtime":"js"},{"bundler":"zisi","buildData":{"runtimeAPIVersion":1},"mainFile":"/home/ubuntu/cm-oauth-setup/compliance-backend/.netlify/functions/jobs_monthlysummary.js","name":"jobs_monthlysummary","priority":10,"path":"/home/ubuntu/cm-oauth-setup/compliance-backend/.netlify/functions/jobs_monthlysummary.zip","runtime":"js"},{"bundler":"zisi","buildData":{"runtimeAPIVersion":1},"mainFile":"/home/ubuntu/cm-oauth-setup/compliance-backend/.netlify/functions/ping.js","name":"ping","priority":10,"path":"/home/ubuntu/cm-oauth-setup/compliance-backend/.netlify/functions/ping.zip","runtime":"js"},{"bundler":"zisi","buildData":{"runtimeAPIVersion":1},"mainFile":"/home/ubuntu/cm-oauth-setup/compliance-backend/.netlify/functions/settings_get.js","name":"settings_get","priority":10,"path":"/home/ubuntu/cm-oauth-setup/compliance-backend/.netlify/functions/settings_get.zip","runtime":"js"},{"bundler":"zisi","buildData":{"runtimeAPIVersion":1},"mainFile":"/home/ubuntu/cm-oauth-setup/compliance-backend/.netlify/functions/settings_update.js","name":"settings_update","priority":10,"path":"/home/ubuntu/cm-oauth-setup/compliance-backend/.netlify/functions/settings_update.zip","runtime":"js"},{"bundler":"zisi","buildData":{"runtimeAPIVersion":1},"mainFile":"/home/ubuntu/cm-oauth-setup/compliance-backend/.netlify/functions/tasks_bulkimportcsv.js","name":"tasks_bulkimportcsv","priority":10,"path":"/home/ubuntu/cm-oauth-setup/compliance-backend/.netlify/functions/tasks_bulkimportcsv.zip","runtime":"js"},{"bundler":"zisi","buildData":{"runtimeAPIVersion":1},"mainFile":"/home/ubuntu/cm-oauth-setup/compliance-backend/.netlify/functions/tasks_createone.js","name":"tasks_createone","priority":10,"path":"/home/ubuntu/cm-oauth-setup/compliance-backend/.netlify/functions/tasks_createone.zip","runtime":"js"},{"bundler":"zisi","buildData":{"runtimeAPIVersion":1},"mainFile":"/home/ubuntu/cm-oauth-setup/compliance-backend/.netlify/functions/tasks_updatestatus.js","name":"tasks_updatestatus","priority":10,"path":"/home/ubuntu/cm-oauth-setup/compliance-backend/.netlify/functions/tasks_updatestatus.zip","runtime":"js"},{"bundler":"zisi","buildData":{"runtimeAPIVersion":1},"mainFile":"/home/ubuntu/cm-oauth-setup/compliance-backend/.netlify/functions/tasks_uploadattachment.js","name":"tasks_uploadattachment","priority":10,"path":"/home/ubuntu/cm-oauth-setup/compliance-backend/.netlify/functions/tasks_uploadattachment.zip","runtime":"js"}],"system":{"arch":"arm64","platform":"linux"},"timestamp":1768909789240,"version":1}

       --- File Content End ---


    =� ping.js

       --- File Content Start ---

exports.handler = async () => {
  return {
    statusCode: 200,
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ ok: true, msg: "ping works" })
  };
};


       --- File Content End ---


    =� settings_get.js

       --- File Content Start ---

const { withCors, json, db } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const snap = await db().collection('settings').doc('notifications').get();
  const data = snap.exists ? snap.data() : null;

  return json(event, 200, {
    ok:true,
    data: data || {
      dailyInternalEmails: [],
      dailyWindowDays: 30,
      sendDailyToAssignees: true,
      lastDailyRunYmd: null
    }
  });
});

       --- File Content End ---


    =� settings_update.js

       --- File Content Start ---

const { withCors, json, db, admin } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');

function asEmailList(x) {
  if (Array.isArray(x)) return x.map(s => String(s).trim()).filter(Boolean);
  if (typeof x === 'string') return x.split(/[;,]/).map(s => s.trim()).filter(Boolean);
  return [];
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const body = JSON.parse(event.body || '{}');

  const doc = {
    dailyInternalEmails: asEmailList(body.dailyInternalEmails),
    dailyWindowDays: Number(body.dailyWindowDays || 30),
    sendDailyToAssignees: body.sendDailyToAssignees !== false,
    updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    updatedBy: user.email
  };

  await db().collection('settings').doc('notifications').set(doc, { merge: true });
  return json(event, 200, { ok:true });
});

       --- File Content End ---


    =� tasks_bulkimportcsv.js

       --- File Content Start ---

const { withCors, json, db, admin, calendar, dmyToYmd, ymd, addInterval, addDays, calTimeRange, auditLog } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');
const { parse } = require('csv-parse/sync');

async function findOrCreateClientByName(clientName) {
  const snap = await db().collection('clients').where('name', '==', clientName).limit(1).get();
  if (!snap.empty) return snap.docs[0].id;

  const ref = db().collection('clients').doc();
  await ref.set({
    name: clientName,
    pan: '', gstin: '', cin: '',
    assessmentYear: '', engagementType: '',
    primaryEmail: '',
    ccEmails: [], bccEmails: [],
    driveFolderId: null,
    createdAt: admin.firestore.FieldValue.serverTimestamp()
  });
  return ref.id;
}

async function findUserUidByEmail(email) {
  if (!email) return null;
  const snap = await db().collection('users').where('email', '==', email).limit(1).get();
  if (snap.empty) return null;
  return snap.docs[0].id;
}

function normalizeRecurrence(x) {
  const r = String(x || 'AD_HOC').toUpperCase().trim();
  const allowed = ['AD_HOC','DAILY','WEEKLY','BIWEEKLY','MONTHLY','BIMONTHLY','QUARTERLY','HALF_YEARLY','YEARLY'];
  return allowed.includes(r) ? r : 'AD_HOC';
}

async function createTwoCalendarEvents({ title, clientId, startDateYmd, dueDateYmd }) {
  const cal = calendar();

  const startRange = calTimeRange(startDateYmd, 10, 12);
  const dueRange = calTimeRange(dueDateYmd, 10, 12);

  const startRes = await cal.events.insert({
    calendarId: 'primary',
    sendUpdates: 'none',
    requestBody: {
      summary: `START: ${title}`,
      description: `ClientId: ${clientId}\nStart: ${startDateYmd}\nDue: ${dueDateYmd}`,
      ...startRange
    }
  });

  const dueRes = await cal.events.insert({
    calendarId: 'primary',
    sendUpdates: 'none',
    requestBody: {
      summary: `DUE: ${title}`,
      description: `ClientId: ${clientId}\nStart: ${startDateYmd}\nDue: ${dueDateYmd}`,
      ...dueRange
    }
  });

  return {
    calendarStartEventId: startRes.data.id,
    calendarDueEventId: dueRes.data.id
  };
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const body = JSON.parse(event.body || '{}');
  const csvText = body.csvText;
  if (!csvText) return json(event, 400, { ok:false, error:'csvText required' });

  const records = parse(csvText, { columns: true, skip_empty_lines: true, trim: true });

  let created = 0;

  for (const r of records) {
    const title = r.Title;
    const clientName = r.Client;

    // CSV DueDate is DD-MM-YYYY
    const dueDateBaseYmd = dmyToYmd(r.DueDate);
    const dueDateBase = new Date(`${dueDateBaseYmd}T00:00:00`);

    const recurrence = normalizeRecurrence(r.Recurrence);
    const generateCount = Math.max(1, parseInt(r.GenerateCount || '1', 10));
    const triggerDaysBefore = Math.max(0, parseInt(r.TriggerDays || '15', 10));
    const type = (r.Type || 'FILING').toUpperCase();
    const category = (r.Category || 'OTHER').toUpperCase();

    const assignedEmail = (r.AssignedToEmail || '').trim() || null;
    const clientEmail = (r.ClientEmail || '').trim() || null;

    const clientStartSubject = (r.ClientStartSubject || '').trim();
    const clientStartBody = (r.ClientStartBody || '').trim();

    if (!title || !clientName || !r.DueDate) continue;

    const clientId = await findOrCreateClientByName(clientName);

    // If CSV has client email, update client.primaryEmail if empty
    if (clientEmail) {
      const cRef = db().collection('clients').doc(clientId);
      const cSnap = await cRef.get();
      if (cSnap.exists && !cSnap.data().primaryEmail) {
        await cRef.update({ primaryEmail: clientEmail });
      }
    }

    const assignedToUid = (await findUserUidByEmail(assignedEmail)) || user.uid;

    const isSeries = recurrence !== 'AD_HOC' && generateCount > 1;
    const seriesId = isSeries ? db().collection('taskSeries').doc().id : null;

    for (let i = 0; i < generateCount; i++) {
      const dueDate = addInterval(dueDateBase, recurrence, i);
      const dueDateYmd = ymd(dueDate);

      const startDate = addDays(dueDate, -triggerDaysBefore);
      const startDateYmd = ymd(startDate);

      const events = await createTwoCalendarEvents({ title, clientId, startDateYmd, dueDateYmd });

      const tRef = db().collection('tasks').doc();

      await tRef.set({
        clientId,
        title,
        category,
        type,
        recurrence,

        seriesId,
        occurrenceIndex: i + 1,
        occurrenceTotal: generateCount,

        dueDate: admin.firestore.Timestamp.fromDate(new Date(`${dueDateYmd}T00:00:00`)),
        dueDateYmd,

        triggerDaysBefore,
        startDate: admin.firestore.Timestamp.fromDate(new Date(`${startDateYmd}T00:00:00`)),
        startDateYmd,

        assignedToUid,
        assignedToEmail: assignedEmail || user.email,

        status: 'PENDING',
        statusNote: '',
        delayReason: null,
        delayNotes: '',

        calendarStartEventId: events.calendarStartEventId,
        calendarDueEventId: events.calendarDueEventId,

        clientStartSubject,
        clientStartBody,
        clientStartMailSent: false,
        clientStartMailSentAt: null,

        createdByUid: user.uid,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),

        completedRequestedAt: null,
        completedAt: null,

        attachments: []
      });

      await auditLog({
        taskId: tRef.id,
        action: 'TASK_CREATED',
        actorUid: user.uid,
        actorEmail: user.email,
        details: { source:'CSV', seriesId, occurrenceIndex: i+1, startDateYmd, dueDateYmd }
      });

      created++;
    }
  }

  return json(event, 200, { ok:true, created });
});

       --- File Content End ---


    =� tasks_createone.js

       --- File Content Start ---

const { withCors, json, db, admin, ymd, addDays, addInterval, calTimeRange, calendar, auditLog } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');

async function findOrCreateClientByIdOrName({ clientId, clientName, clientEmail }) {
  if (clientId) {
    const cRef = db().collection('clients').doc(clientId);
    const cSnap = await cRef.get();
    if (!cSnap.exists) throw new Error('Client not found: ' + clientId);
    if (clientEmail && !cSnap.data().primaryEmail) await cRef.update({ primaryEmail: clientEmail });
    return clientId;
  }

  if (!clientName) throw new Error('clientId or clientName required');

  const snap = await db().collection('clients').where('name', '==', clientName).limit(1).get();
  if (!snap.empty) {
    const id = snap.docs[0].id;
    const cRef = db().collection('clients').doc(id);
    const cSnap = await cRef.get();
    if (clientEmail && cSnap.exists && !cSnap.data().primaryEmail) await cRef.update({ primaryEmail: clientEmail });
    return id;
  }

  const ref = db().collection('clients').doc();
  await ref.set({
    name: clientName,
    primaryEmail: clientEmail || '',
    ccEmails: [],
    bccEmails: [],
    createdAt: admin.firestore.FieldValue.serverTimestamp()
  });
  return ref.id;
}

async function findUserUidByEmail(email) {
  if (!email) return null;
  const snap = await db().collection('users').where('email', '==', email).limit(1).get();
  if (snap.empty) return null;
  return snap.docs[0].id;
}

function normalizeRecurrence(x) {
  const r = String(x || 'AD_HOC').toUpperCase().trim();
  const allowed = ['AD_HOC','DAILY','WEEKLY','BIWEEKLY','MONTHLY','BIMONTHLY','QUARTERLY','HALF_YEARLY','YEARLY'];
  return allowed.includes(r) ? r : 'AD_HOC';
}

async function createTwoCalendarEvents({ title, clientId, startDateYmd, dueDateYmd }) {
  const cal = calendar();
  const startRange = calTimeRange(startDateYmd, 10, 12);
  const dueRange = calTimeRange(dueDateYmd, 10, 12);

  const startRes = await cal.events.insert({
    calendarId: 'primary',
    sendUpdates: 'none',
    requestBody: {
      summary: `START: ${title}`,
      description: `ClientId: ${clientId}\nStart: ${startDateYmd}\nDue: ${dueDateYmd}`,
      ...startRange
    }
  });

  const dueRes = await cal.events.insert({
    calendarId: 'primary',
    sendUpdates: 'none',
    requestBody: {
      summary: `DUE: ${title}`,
      description: `ClientId: ${clientId}\nStart: ${startDateYmd}\nDue: ${dueDateYmd}`,
      ...dueRange
    }
  });

  return { calendarStartEventId: startRes.data.id, calendarDueEventId: dueRes.data.id };
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const body = JSON.parse(event.body || '{}');

  const clientId = await findOrCreateClientByIdOrName({
    clientId: body.clientId || null,
    clientName: body.clientName || null,
    clientEmail: body.clientEmail || null,
  });

  const title = body.title || 'Untitled';
  const dueDateBaseYmd = body.dueDateYmd;
  if (!dueDateBaseYmd) return json(event, 400, { ok:false, error:'dueDateYmd required' });

  const recurrence = normalizeRecurrence(body.recurrence || 'AD_HOC');
  const generateCount = Math.max(1, parseInt(body.generateCount || '1', 10));

  const triggerDaysBefore = Math.max(0, parseInt(body.triggerDaysBefore ?? 15, 10));

  const assignedToEmail = body.assignedToEmail || user.email;
  const assignedToUid = (await findUserUidByEmail(assignedToEmail)) || user.uid;

  const category = (body.category || 'OTHER').toUpperCase();
  const type = (body.type || 'FILING').toUpperCase();

  const clientStartSubject = body.clientStartSubject || '';
  const clientStartBody = body.clientStartBody || '';

  const isSeries = recurrence !== 'AD_HOC' && generateCount > 1;
  const seriesId = isSeries ? db().collection('taskSeries').doc().id : null;

  let created = 0;

  for (let i = 0; i < generateCount; i++) {
    const dueDate = addInterval(new Date(dueDateBaseYmd), recurrence, i);
    const dueDateYmd = ymd(dueDate);
    const startDateYmd = ymd(addDays(dueDate, -triggerDaysBefore));

    const ev = await createTwoCalendarEvents({ title, clientId, startDateYmd, dueDateYmd });

    const tRef = db().collection('tasks').doc();
    await tRef.set({
      clientId,
      title,
      category,
      type,
      recurrence,

      seriesId,
      occurrenceIndex: i + 1,
      occurrenceTotal: generateCount,

      dueDate: admin.firestore.Timestamp.fromDate(dueDate),
      dueDateYmd,

      triggerDaysBefore,
      startDate: admin.firestore.Timestamp.fromDate(new Date(startDateYmd)),
      startDateYmd,

      assignedToUid,
      assignedToEmail,

      status: 'PENDING',
      statusNote: '',
      delayReason: null,
      delayNotes: '',

      calendarStartEventId: ev.calendarStartEventId,
      calendarDueEventId: ev.calendarDueEventId,

      clientStartSubject,
      clientStartBody,
      clientStartMailSent: false,
      clientStartMailSentAt: null,

      createdByUid: user.uid,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),

      completedRequestedAt: null,
      completedAt: null,

      attachments: []
    });

    await auditLog({ taskId: tRef.id, action:'TASK_CREATED', actorUid:user.uid, actorEmail:user.email, details:{ source:'UI_CREATE', seriesId, occurrenceIndex: i+1 } });
    created++;
  }

  return json(event, 200, { ok:true, created, seriesId });
});

       --- File Content End ---


    =� tasks_updatestatus.js

       --- File Content Start ---

const { withCors, json, db, admin, calendar, sendEmail, auditLog, calTimeRange } = require('./_common');
const { requireUser } = require('./_auth');

async function patchEvent(eventId, ymdStr, summary, description, colorId=null) {
  if (!eventId) return;
  const cal = calendar();
  const range = calTimeRange(ymdStr, 10, 12);

  await cal.events.patch({
    calendarId: 'primary',
    eventId,
    sendUpdates: 'none',
    requestBody: {
      summary,
      description,
      ...range,
      ...(colorId ? { colorId } : {})
    }
  });
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const body = JSON.parse(event.body || '{}');
  const { taskId, newStatus, statusNote, delayReason, delayNotes } = body;
  if (!taskId || !newStatus) return json(event, 400, { ok:false, error:'taskId,newStatus required' });

  const tRef = db().collection('tasks').doc(taskId);
  const tSnap = await tRef.get();
  if (!tSnap.exists) return json(event, 404, { ok:false, error:'Task not found' });

  const task = tSnap.data();
  const isPartner = user.role === 'PARTNER';
  const isAssignee = task.assignedToUid === user.uid;
  if (!isPartner && !isAssignee) return json(event, 403, { ok:false, error:'Not allowed' });

  if (!isPartner && newStatus === 'COMPLETED') {
    return json(event, 403, { ok:false, error:'Only partner can mark COMPLETED' });
  }

  const updates = {
    status: newStatus,
    updatedAt: admin.firestore.FieldValue.serverTimestamp(),
  };

  if (typeof statusNote === 'string') updates.statusNote = statusNote;
  if (delayReason) updates.delayReason = delayReason;
  if (typeof delayNotes === 'string') updates.delayNotes = delayNotes;

  if (newStatus === 'APPROVAL_PENDING') updates.completedRequestedAt = admin.firestore.FieldValue.serverTimestamp();
  if (newStatus === 'COMPLETED') updates.completedAt = admin.firestore.FieldValue.serverTimestamp();

  await tRef.update(updates);

  await auditLog({
    taskId,
    action: 'STATUS_CHANGE',
    actorUid: user.uid,
    actorEmail: user.email,
    details: { from: task.status, to: newStatus, statusNote: statusNote || '' }
  });

  if (newStatus === 'COMPLETED') {
    const desc = `ClientId: ${task.clientId}\nStart: ${task.startDateYmd}\nDue: ${task.dueDateYmd}\nTaskId: ${taskId}`;

    // Patch both events green
    try {
      await patchEvent(task.calendarStartEventId, task.startDateYmd, `[COMPLETED] START: ${task.title}`, desc, '2');
      await patchEvent(task.calendarDueEventId, task.dueDateYmd, `[COMPLETED] DUE: ${task.title}`, desc, '2');
    } catch (e) {
      // ignore calendar failures; still email
    }

    // Email client on completion
    const cSnap = await db().collection('clients').doc(task.clientId).get();
    const client = cSnap.exists ? cSnap.data() : {};
    const to = client.primaryEmail ? [client.primaryEmail] : [];
    const cc = client.ccEmails || [];
    const bcc = client.bccEmails || [];

    if (to.length) {
      const html = `
        <p>Dear ${client.name || 'Client'},</p>
        <p>We have completed: <b>${task.title}</b></p>
        <p>Due date: <b>${task.dueDateYmd}</b></p>
        <p>Status note: ${updates.statusNote || task.statusNote || ''}</p>
        <p>Regards,<br>${process.env.MAIL_SIGNATURE || 'Compliance Team'}</p>
      `;

      await sendEmail({ to, cc, bcc, subject: `Completed: ${task.title} (${client.name || ''})`, html });
      await auditLog({ taskId, action:'EMAIL_SENT', actorUid:null, actorEmail:null, details:{ type:'CLIENT_COMPLETION' } });
    }
  }

  return json(event, 200, { ok:true });
});

       --- File Content End ---


    =� tasks_updatetask.js

       --- File Content Start ---

const { withCors, json, db, admin, calendar, ymd, addDays, calTimeRange, auditLog } = require('./_common');
const { requireUser, requirePartner } = require('./_auth');

async function findUserUidByEmail(email) {
  if (!email) return null;
  const snap = await db().collection('users').where('email', '==', email).limit(1).get();
  if (snap.empty) return null;
  return snap.docs[0].id;
}

async function patchEvent(eventId, ymdStr, summary, description, colorId=null) {
  if (!eventId) return;
  const cal = calendar();
  const range = calTimeRange(ymdStr, 10, 12);

  await cal.events.patch({
    calendarId: 'primary',
    eventId,
    sendUpdates: 'none',
    requestBody: {
      summary,
      description,
      ...range,
      ...(colorId ? { colorId } : {})
    }
  });
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const p = requirePartner(event, user);
  if (p.error) return p.error;

  const body = JSON.parse(event.body || '{}');
  const taskId = body.taskId;
  if (!taskId) return json(event, 400, { ok:false, error:'taskId required' });

  const baseRef = db().collection('tasks').doc(taskId);
  const baseSnap = await baseRef.get();
  if (!baseSnap.exists) return json(event, 404, { ok:false, error:'Task not found' });

  const base = baseSnap.data();
  const applyToSeries = !!body.applyToSeries && !!base.seriesId;

  // Fields allowed to edit
  const newTitle = (body.title ?? base.title);
  const newCategory = (body.category ?? base.category);
  const newType = (body.type ?? base.type);
  const newTrigger = body.triggerDaysBefore !== undefined ? Math.max(0, parseInt(body.triggerDaysBefore, 10)) : base.triggerDaysBefore;

  const newAssignedEmail = (body.assignedToEmail ?? base.assignedToEmail);
  const newAssignedUid = (await findUserUidByEmail(newAssignedEmail)) || base.assignedToUid;

  const newClientStartSubject = (body.clientStartSubject ?? base.clientStartSubject ?? '');
  const newClientStartBody = (body.clientStartBody ?? base.clientStartBody ?? '');

  // Optional: allow dueDate edit ONLY if NOT applyToSeries (single)
  const newDueDateYmd = (!applyToSeries && body.dueDateYmd) ? String(body.dueDateYmd).trim() : base.dueDateYmd;

  // Determine target tasks
  let targets = [];
  if (applyToSeries) {
    const snap = await db().collection('tasks').where('seriesId', '==', base.seriesId).get();
    targets = snap.docs.map(d => ({ id: d.id, ref: d.ref, data: d.data() }));
  } else {
    targets = [{ id: taskId, ref: baseRef, data: base }];
  }

  // Update tasks + patch calendar
  let updatedCount = 0;

  for (const t of targets) {
    const old = t.data;

    const dueYmd = (t.id === taskId) ? newDueDateYmd : old.dueDateYmd;
    const startYmd = ymd(addDays(new Date(dueYmd), -newTrigger));

    const updateDoc = {
      title: newTitle,
      category: String(newCategory).toUpperCase(),
      type: String(newType).toUpperCase(),
      triggerDaysBefore: newTrigger,

      assignedToEmail: newAssignedEmail,
      assignedToUid: newAssignedUid,

      clientStartSubject: newClientStartSubject,
      clientStartBody: newClientStartBody,

      // recompute startDate
      startDateYmd: startYmd,
      startDate: admin.firestore.Timestamp.fromDate(new Date(startYmd)),

      // allow single due date update
      ...(t.id === taskId ? { dueDateYmd: dueYmd, dueDate: admin.firestore.Timestamp.fromDate(new Date(dueYmd)) } : {}),

      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    };

    await t.ref.update(updateDoc);

    // Patch calendar events
    const desc = `ClientId: ${old.clientId}\nStart: ${startYmd}\nDue: ${dueYmd}\nTaskId: ${t.id}`;

    await patchEvent(old.calendarStartEventId, startYmd, `START: ${newTitle}`, desc);
    await patchEvent(old.calendarDueEventId, dueYmd, `DUE: ${newTitle}`, desc);

    await auditLog({
      taskId: t.id,
      action: 'TASK_EDITED',
      actorUid: user.uid,
      actorEmail: user.email,
      details: { applyToSeries, baseTaskId: taskId }
    });

    updatedCount++;
  }

  return json(event, 200, { ok:true, updatedCount, applyToSeries, seriesId: base.seriesId || null });
});

       --- File Content End ---


    =� tasks_uploadattachment.js

       --- File Content Start ---

const Busboy = require('busboy');
const { withCors, json, db, admin, drive, auditLog } = require('./_common');
const { requireUser } = require('./_auth');

async function ensureRootFolder() {
  const d = drive();
  const name = process.env.DRIVE_ROOT_FOLDER_NAME || 'ComplianceManagement';

  const res = await d.files.list({
    q: `mimeType='application/vnd.google-apps.folder' and name='${name}' and trashed=false`,
    fields: 'files(id,name)',
    spaces: 'drive'
  });

  if (res.data.files && res.data.files.length) return res.data.files[0].id;

  const created = await d.files.create({
    requestBody: { name, mimeType: 'application/vnd.google-apps.folder' },
    fields: 'id'
  });
  return created.data.id;
}

async function ensureClientFolder(clientId) {
  const cRef = db().collection('clients').doc(clientId);
  const cSnap = await cRef.get();
  const client = cSnap.data();
  if (client.driveFolderId) return client.driveFolderId;

  const rootId = await ensureRootFolder();
  const folderName = `${client.name || 'Client'}_${clientId}`;

  const d = drive();
  const created = await d.files.create({
    requestBody: {
      name: folderName,
      mimeType: 'application/vnd.google-apps.folder',
      parents: [rootId]
    },
    fields: 'id'
  });

  await cRef.update({ driveFolderId: created.data.id });
  return created.data.id;
}

exports.handler = withCors(async (event) => {
  if (event.httpMethod !== 'POST') return json(event, 405, { ok:false, error:'POST only' });

  const authRes = await requireUser(event);
  if (authRes.error) return authRes.error;
  const { user } = authRes;

  const busboy = Busboy({ headers: event.headers });

  let taskId = null;
  let attachmentType = 'OTHER';
  let fileBuffer = Buffer.alloc(0);
  let fileName = 'file';
  let mimeType = 'application/octet-stream';

  busboy.on('field', (name, val) => {
    if (name === 'taskId') taskId = val;
    if (name === 'type') attachmentType = String(val || 'OTHER').toUpperCase();
  });

  busboy.on('file', (name, file, info) => {
    fileName = info.filename || 'file';
    mimeType = info.mimeType || 'application/octet-stream';
    file.on('data', (d) => { fileBuffer = Buffer.concat([fileBuffer, d]); });
  });

  const done = new Promise((resolve, reject) => {
    busboy.on('finish', resolve);
    busboy.on('error', reject);
  });

  const bodyBuf = event.isBase64Encoded ? Buffer.from(event.body, 'base64') : Buffer.from(event.body || '');
  busboy.end(bodyBuf);
  await done;

  if (!taskId) return json(event, 400, { ok:false, error:'taskId required' });

  const tRef = db().collection('tasks').doc(taskId);
  const tSnap = await tRef.get();
  if (!tSnap.exists) return json(event, 404, { ok:false, error:'Task not found' });

  const task = tSnap.data();
  const isPartner = user.role === 'PARTNER';
  const isAssignee = task.assignedToUid === user.uid;
  if (!isPartner && !isAssignee) return json(event, 403, { ok:false, error:'Not allowed' });

  const folderId = await ensureClientFolder(task.clientId);

  const created = await drive().files.create({
    requestBody: { name: fileName, parents: [folderId] },
    media: { mimeType, body: Buffer.from(fileBuffer) },
    fields: 'id, webViewLink'
  });

  const attachment = {
    type: attachmentType,
    fileName,
    mimeType,
    driveFileId: created.data.id,
    driveWebViewLink: created.data.webViewLink,
    uploadedByUid: user.uid,
    uploadedAt: admin.firestore.FieldValue.serverTimestamp()
  };

  await tRef.update({
    attachments: admin.firestore.FieldValue.arrayUnion(attachment),
    updatedAt: admin.firestore.FieldValue.serverTimestamp()
  });

  await auditLog({ taskId, action:'ATTACHMENT_UPLOAD', actorUid:user.uid, actorEmail:user.email, details:{ fileName, type: attachmentType } });

  return json(event, 200, { ok:true, attachment });
});

       --- File Content End ---

